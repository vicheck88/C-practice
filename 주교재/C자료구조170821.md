# 배열 기반 선형 자료구조
## 순차 리스트
### 자료처리
- 기계에서 자료를 어떻게 관리, 처리할까 고민하는 것
- 주요 동작
	- 자료생성: 관리 자료를 모델링하며, 주로 구조체를 활용
	- 자료보관: 비휘발성 메모리에 기록: 자료는 비휘발성이어야 함
	- 자료활용: 원하는 자료의 탐색, 변경, 삭제 등의 동작을 수행

### 자료구조
- 자료구조: 자료를 효율적으로 관리, 활용하기 위한 시스템
- 관리, 활용, 가공할 데이터를 보관하기 위한 시스템 의미
- 자료구조 형태
	- 선형 구조: 자료들이 열을 지어서 저장되느니 구조(list, stack, queue 등)
	- 비선형 구조: 자료들이 산발적으로 존재하는 구조
	- 파일 구조: 파일 시스템의 형식으로 저장되어 존재하는 방법

### 배열기반 sequence list
- 순차리스트: 배열 요소번호가 곧 정렬된 자료의 순서
- 기본 자료를 구조체 등으로 만들고, 이들 전체는 배열에 저장
	- 배열에 있어 관리에 유리
	- 데이터가 모여있으므로 쓰기/읽기가 편리
	- 최대 자료 개수가 미리 지정되어있는 경우의 시스템에 유리

```cpp
typedef struct _score // score 타입 생성
{
	int id;
	int jumsu;
	char name[10];
}SCORE;

#define MAX_ST	20

SCORE exam[MAX_ST]; // 자료를 저장할 Buffer 생성

SCORE test[10] = {{10, 50, "kim"}, {2, 80, "lew"}, {8, 50, "lew"}, {4, 45, "lee"}, {1, 90, "song"}, {3, 45, "kim"}, {5, 50, "song"}, {9, 100, "lee"}, {7, 75, "moon"}, {6, 90, "park"}}; 

void Make_Test_Data(int n) // 데이터를 저장할 함수 설계
{
	int i;

	for(i=0; i<n; i++)
	{
		exam[i] = test[i];
	}
}
```

## 연결 리스트
### Singly Linked List
- 순차리스트의 단점
	- 순서대로 자료가 정렬되어야 함: 자료의 이동이 빈번
- Linked List: 배열 요소(구조체)의 위치는 그대로 두고 이들 간의 정렬 순서만을 정함
	- 자료들 간에 Link를 만들어 앞, 뒤 관계를 연결하는 방식
	- 자료를 Node, 연결주소를 Link라고 부름
	- 첫 자료가 다음에 위치할 자료의 주소를 구조체 멤버로 가지고 있음
	- 다음 자료가 메모리에 연속할 필요가 없어 좀 더 효율적
	- 자기참조구조체를 통해 linked list 구현
	- singly linked: 다음으로 이어지는 자료의 정보(next)만을 포함
	- doubly linked: 이전 자료의 정보(prev)도 포함
		- head와 tail이 연결될 경우, 자료는 원형(circular)

![linked list.png](C:\Users\student\Desktop\C-practice\주교재\image\linked list.png)

### 자료의 추가와 삭제
- 추가: 새 자료가 들어갈 위치를 찾은 뒤, 앞뒤 링크를 변경하여 추가
![linked list.new.bmp](C:\Users\student\Desktop\C-practice\주교재\image\linked list.new.bmp)


- 제거: 삭제될 자료를 찾은 뒤 앞의 링크를 변경
![Single_Linked_List_Method_remove.png](C:\Users\student\Desktop\C-practice\주교재\image\Single_Linked_List_Method_remove.png)

### 구현
- list의 처음(head)를 먼저 구현
	- Head 구조체의 내용은 의미가 없으며, 오직 다음 구조체의 주소를 저장하는 용도로 사용함
	- Head 구조체는 배열과 별도로 선언
	- 그 후, 주소를 통해 배열들을 서로 연결, list 생성
- while, 혹은 for 문을 이용하여 노드들을 비교: 함수를 통해 Head 구조체를 바로 이전의 구조체로 바꿀 때 좀 더 간편하게 삽입이 가능

```cpp
int Insert_Node(SCORE * head, SCORE * d) //노드 삽입 함수 생성
{
	{
	int i;
	for (i = 0; i < MAX_ST; i++)
	// 자료가 입력되지 않았을 경우, 또는 투입되는 값이 가장 클 경우
	{
		if (head->next == NULL || head->next->id > d->id)
		{
			d->next = head->next; // 이전 노드들과 새 노드를 연결하는 과정
			head->next = d;
			return 1;
		}
		if (head->next->id == d->id) return -2;
		head = head->next;
		// head의 주소를 다음 노드의 주소로 변경: 링크를 다루기 좀 더 용이해짐
	}
	return -1;
}
```
```cpp
int Delete_Node(SCORE * head, int id) 
//노드 삭제 함수: 노드들이 오름차순으로 정렬되어있다 가정
{
	int i;
	for (i = 0; i < MAX_ST; i++)
	{
		if (head->next == NULL) return -1;
		if (head->next->id == id)
		{
			head->next->id = 0;
			head->next = head->next->next;
			return 1;
		}
		if (head->next->id > id) return -1; 
        //id보다 큰 곳으로 간 경우, 해당 id가 없음을 의미: -1 리턴
		head = head->next;
	}
}
```

### 다중 연결 리스트
- 사번으로 정렬된 링크에서 다른 정렬(이름)을 수행할 경우, 기존 방식으로는 다시 한번 멤버들을 복사, 정렬해야함
- 미리 정렬을 위한 링크를 만들 때 좀 더 편리
- 자료의 탐색, 활용이 더 많아 유리하지만, 삽입, 삭제시 모든 링크를 수정해야 하므로 속도가 느려짐
	- 두가지 항목으로 정렬되어 있는 경우, 루프를 두 번 돌려야 함

![다중링크리스트.jpg](.\image\다중링크리스트.jpg)

