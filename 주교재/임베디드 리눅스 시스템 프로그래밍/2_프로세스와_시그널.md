# 프로세스와 시그널
## 프로세스
### 프로세스
- 프로세스는 현재 실행 중인 하나의 프로그램
- 멀티태스킹 환경이 지원되지 않을 경우 프로세스는 한 번에 한 개만 실행 가능
	- 리눅스는 멀티태스킹 운영체제: 동시에 여러 개의 프로세스 실행
	- ps 명령을 통해 현재 실행중인 프로세스 목록 확인 가능
	- UID: 프로세스를 실행한 유저의 ID
	- PID: 프로세스의 ID, PPID: 프로세스 부모의 ID
	- PID 0: 커널 자체를 의미하며 init(PID 1),kthreadd(PID 2)의 부모
	- 나머지 프로세스들은 전부 init,kthradd의 자식에 해당

```bash
	user@user-VirtualBox:~$ ps -ef
	UID        PID  PPID  C STIME TTY          TIME CMD
	root         1     0  0 08:03 ?        00:00:01 /sbin/init
	root         2     0  0 08:03 ?        00:00:00 [kthreadd]
	root         3     2  0 08:03 ?        00:00:02 [ksoftirqd/0]
	root         5     2  0 08:03 ?        00:00:00 [kworker/0:0H]
	root         7     2  0 08:03 ?        00:00:01 [rcu_sched]
	root         8     2  0 08:03 ?        00:00:00 [rcu_bh]
	root         9     2  0 08:03 ?        00:00:00 [migration/0]
	root        10     2  0 08:03 ?        00:00:00 [watchdog/0]
	root        11     2  0 08:03 ?        00:00:00 [watchdog/1]
	root        12     2  0 08:03 ?        00:00:00 [migration/1]
	root        13     2  0 08:03 ?        00:00:00 [ksoftirqd/1]
	root        14     2  0 08:03 ?        00:00:00 [kworker/1:0]
	root        15     2  0 08:03 ?        00:00:00 [kworker/1:0H]
	root        16     2  0 08:03 ?        00:00:00 [watchdog/2]
	root        17     2  0 08:03 ?        00:00:00 [migration/2]
	root        18     2  0 08:03 ?        00:00:00 [ksoftirqd/2]
	root        20     2  0 08:03 ?        00:00:00 [kworker/2:0H]
	root        21     2  0 08:03 ?        00:00:00 [watchdog/3]
	root        22     2  0 08:03 ?        00:00:00 [migration/3]
	root        23     2  0 08:03 ?        00:00:00 [ksoftirqd/3]
	...
````

### 프로세스 주소 공간 주소
- `/proc`는 프로세스들을 관리(PID들로 이루어진 폴더가 있음)
- 주소 공간은 프로세스마다 독립적

```bash
	user@user-VirtualBox:~$ sudo cat /proc/1/maps
	// /proc에서 PID가 1인 프로세스의 메모리 정보를 보여줌
	[sudo] password for user: 
	b7422000-b742d000 r-xp 00000000 08:01 790848     /lib/i386-linux-gnu/libnss_files-2.19.so
	b742d000-b742e000 r--p 0000a000 08:01 790848     /lib/i386-linux-gnu/libnss_files-2.19.so
	b742e000-b742f000 rw-p 0000b000 08:01 790848     /lib/i386-linux-gnu/libnss_files-2.19.so
	b742f000-b7439000 r-xp 00000000 08:01 786534     /lib/i386-linux-gnu/libnss_nis-2.19.so
	b7439000-b743a000 r--p 00009000 08:01 786534     /lib/i386-linux-gnu/libnss_nis-2.19.so
	b743a000-b743b000 rw-p 0000a000 08:01 786534     /lib/i386-
	...
	b774d000-b774e000 rw-p 00020000 08:01 786533     /lib/i386-linux-gnu/ld-2.19.so
	b774e000-b778a000 r-xp 00000000 08:01 1572934    /sbin/init
	b778a000-b778b000 r--p 0003c000 08:01 1572934    /sbin/init
	b778b000-b778c000 rw-p 0003d000 08:01 1572934    /sbin/init
	b90c9000-b91cf000 rw-p 00000000 00:00 0          [heap]
	bfd42000-bfd63000 rw-p 00000000 00:00 0          [stack]
````

### 프로세스 주소 공간
- 각 프로세스들은 전체 주소를 혼자 사용한다고 여기고 실행
- 따라서 실제 주소와 프로세스가 생각하는 주소를 일치화시키는 작업이 필요
- MMU(Memory Management Unit)은 가상 주소를 실제 주소로 변환하는 작업 수행
- 프로세스들이 서로 충돌하지 않고 작업을 수행할 수 있도록 함

### 프로세스 상태 보기
- ps 명령을 통해 현재 프로세스 상태를 알 수 있음
- 프로세스들의 기본 상태: running / ready / blocking,sleeping,waiting...
- STAT열에서 상태를 확인
	- R: 실행/실행 대기중
	- D: 이벤트를 기다리는 중 (시그널에 의해 깨어날 수 없음)	
		- 시그널을 통해 강제적6으로 깨어날 수 없음
		- 깨어날 조건이 되어야 깨어날 수 있음
	- S: 이벤트를 기다리는 중 (시그널에 의해 깨어날 수 있음)
		- 조건이 맞지 않아도 시그널을 통해 강제적으로 깨어날 수 있음
	- T: 멈춤 (시그널, 혹은 디버거에 의함)
	- Z: 좀비(defunct) 상태

```bash
	user@user-VirtualBox:~$ ps ax
	  PID TTY      STAT   TIME COMMAND
		1 ?        Ss     0:01 /sbin/init
		2 ?        S      0:00 [kthreadd]
		3 ?        S      0:02 [ksoftirqd/0]
		5 ?        S<     0:00 [kworker/0:0H]
	...
```

![process](http://cfile6.uf.tistory.com/image/2763F54251B34F941FD72A)

출처: http://blog.eairship.kr/256

### 프로세스 생성
1. system(): `int system(const char *command)`
	- 명령을 실행하고 종료할 때까지 대기
	- 명령을 백그라운드로 실행(우선권을 낮춰 실행)할 때에는 종료를 기다리지 않음
	- 실패 시 -1, 성공시 command의 return status 리턴
	- command: 실행할 명령을 의미
	- return status
		- exit code 8비트, 시그널 번호 8비트로 연속적으로 구성
			- return status=0xff00일 때 exit code=0xff
		- 시그널 번호가 0이면 exit code가 유효, exit code가 0이면 시그널 번호가 유효
		- exit code: 프로그램의 종료 코드로, main()의 리턴 혹은 exit()의 인자
		- 실행 불가능한 command의 exit code: 0x7f
		- return status가 0x0001일 때: 시그널 1번에 의해 종료

```cpp
	구현:
	#include <stdio.h>
	#include <stdlib.h>
	#include <sys/wait.h>

	int main(void)
	{
		int ret;

		printf("command = ls -l\n");
		ret = system("ls -l");
		printf("-> ret = %#x (%#x)\n", ret, WEXITSTATUS(ret));
		// WEXITSTATUS: exit code를 추출하는 명령어
		printf("command = wrong command\n");
		ret = system("wrong command");
		printf("-> ret = %#x (%#x)\n", ret, WEXITSTATUS(ret));

		printf("command = sleep 3\n");
		ret = system("sleep 3");
		printf("-> ret = %#x (%#x)\n", ret, WEXITSTATUS(ret));

		printf("command = sleep 3 &\n");
		ret = system("sleep 3 &");
		printf("-> ret = %#x (%#x)\n", ret, WEXITSTATUS(ret));

		return EXIT_SUCCESS;
	}
````