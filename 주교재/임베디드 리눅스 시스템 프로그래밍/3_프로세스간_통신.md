# 프로세스간 통신
## 파이프
### 파일 식별자
- 파일을 열면 int형식의 식별자가 배정
- 이를 이용하여 열린 파일에 접근 가능
	- 프로세스는 파일 식별자 테이블을 통해 식별자를 관리
	- 파일 식별자 중 0,1,2는 고정: 시스템 의존적인 표준 입출력
		- 0: stdin, 1: stdout, 2: stderr
	- 따라서 열린 파일은 식별자 3번부터 배정됨
- `fork()`로 복제시 파일 식별자 테이블 또한 복제됨

![File Descriptor table](http://www.programering.com/images/remote/ZnJvbT1jbmJsb2dzJnVybD1jbWJ3NWlNNGN6TXprek55SWpOeUFqTTNBekwwQUROeEFqTXZNek54WUROMDhTYXYwMmJqNXladnhtWTBsbWJqNXljbGRXWXRsMkx2b0RjMFJIYQ.jpg)

출처: http://www.programering.com/a/MzN0gDNwATg.html

### 파이프
- 파이프는 프로세스들 간의 연결 통로: 이를 통해 통신
- 리눅스 기본 명령어 `|`를 프로그램으로 구현
	- `ls /etc | grep init`: ls 프로세스의 결과를 grep에 전달
	- `|` 역시 파이프라 불림
- `int pipe(int pipefd[2]`
- 기능: 단방향 데이터 채널 설정
- 리턴: 성공시 0, 실패시 errno 설정 후 -1 리턴
- pipefd: 파이프의 양 끝을 의미하는 파일 식별자
	- pipefd[0]: 읽기 끝단, pipefd[1]: 쓰기 끝단
	- 쓰기 끝단에 쓰여진 데이터는 읽기 전까지 커널에 의해 버퍼링됨
- `fork()`로 복제 시 파일 식별자 테이블 또한 복제
- 부모 프로세스에 파이프를 만들고 이를 복제할 경우, 자식도 같은 파이프를 가짐
- 따라서 이를 이용한 통신이 가능
- 부모 자식 간이 아니라면 같은 파이프를 이용한 통신이 불가능

![pipe](https://i.stack.imgur.com/vevLn.png)

출처: https://stackoverflow.com/questions/11538742/get-two-file-descriptors-without-using-pipe

```cpp
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <errno.h>
	#include <string.h>

	#define MAX_BUF 512

	pid_t pid;

	int main(int argc, char **argv)
	{
		int fd_pipe[2];
		int ret;
		char wbuf[MAX_BUF];
		char rbuf[MAX_BUF];
		pid_t pid_temp;


		printf("[%d] running %s\n", pid = getpid(), argv[0]);

		/* open pipe */
		ret = pipe(fd_pipe);
		if(ret == -1) {
				printf("[%d] error: %s\n", pid, strerror(errno));
				return EXIT_FAILURE;
		}

		pid_temp = fork();
		if(pid_temp == -1) {
				printf("[%d] error: %s\n", pid, strerror(errno));
				return EXIT_FAILURE;
		}
		else if(pid_temp == 0) {
				printf("[%d] child running\n", pid = getpid());

				ret = read(fd_pipe[0], rbuf, MAX_BUF);
				//읽기: 읽을 내용일 있을 때까지 대기
				if(ret == -1) {
						printf("[%d] error: %s\n", pid, strerror(errno));
						return EXIT_FAILURE;
				}
				printf("[%d] read %d bytes from pipe [%s]\n", pid, ret, rbuf);
		}
		else {
				int status;

				/* write data to pipe */
				strcpy(wbuf, "hello");
				ret = write(fd_pipe[1], wbuf, strlen(wbuf)+1);
				if(ret == -1) {
						printf("[%d] error: %s\n", pid, strerror(errno));
						return EXIT_FAILURE;
				}
				printf("[%d] wrote %d bytes to pipe [%s]\n", pid, ret, wbuf);

				printf("[%d] waiting child's termination\n", pid);
				pid_temp = wait(&status);
				printf("[%d] pid %d has been terminated with status %#x\n", pid, pid_temp, status);
		}
		printf("[%d] terminated\n", pid);
		return EXIT_SUCCESS;
	}
```

### `dup(), dup2()`
- `int dup(int oldfd);`
- 기능: 파일 식별자를 복제, 새로운 것을 생성
	- 새 파일 식별자는 사용되지 않는 파일 식별자 중 가장 낮은 번호로 배정
- 리턴: 성공시 새 파일 식별자, 실패 시 errno 설정 후 -1 리턴
- oldfd: 복제되는 파일 식별자
- `int dup2(int oldfd,int newfd);`
- 기능: 파일 식별자를 복제, 새로운 것을 생성
	- 새 파일 식별자는 newfd로 번호가 정해짐
- 리턴: 성공 시 새 파일 식별자, 실패시  errno 설정 후 01 리턴
- oldfd: 복제되는 파일 식별자
- newfd: 새 파일 식별자

```cpp
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <errno.h>
	#include <string.h>

	#define MAX_BUF 512

	pid_t pid;

	int main(int argc, char **argv)
	{
		int fd_pipe[2];
		int ret;
		char wbuf[MAX_BUF];
		char rbuf[MAX_BUF];
		pid_t pid_temp;


		printf("[%d] running %s\n", pid = getpid(), argv[0]);
		if(argc < 2) {
				printf("[%d] usage: %s {str1} {str2} ...\n", pid, argv[0]);
				return EXIT_FAILURE;
		}

		/* open pipe */
		ret = pipe(fd_pipe);
		if(ret == -1) {
				printf("[%d] error: %s\n", pid, strerror(errno));
				return EXIT_FAILURE;
		}
		pid_temp = fork();
		if(pid_temp == -1) {
				printf("[%d] error: %s\n", pid, strerror(errno));
				return EXIT_FAILURE;
		}
		else if(pid_temp == 0)
		{
				printf("[%d] child running\n", pid = getpid());

				/* 1: close fd 0 */
				close(0);
				/* 2: duplicate */
				dup(fd_pipe[0]);
				//파이프가 0번 파일 식별자에 위치
				/* 3: close fd_pipe[0] */
				close(fd_pipe[0]);
				/* 4: close fd_pipe[1] */
				close(fd_pipe[1]);

				execlp("tr", "tr", "a-z", "A-Z", NULL);
				//tr: fd 0번에서 읽은 데이터를 처리
				//여기서는 소문자를 대문자로 변경
		}
		else {
				int status;
				int i;

				/* close fd_pipe[0] */
				close(fd_pipe[0]);

				/* write data to pipe */
				strcpy(wbuf, argv[1]);
				for(i=2; i<argc; i++) {
						strcat(wbuf, " ");
						strcat(wbuf, argv[i]);
				}
			   ret = write(fd_pipe[1], wbuf, strlen(wbuf)+1);
				if(ret == -1) {
						printf("[%d] error: %s\n", pid, strerror(errno));
						return EXIT_FAILURE;
				}
				printf("[%d] wrote %d bytes to pipe [%s]\n", pid, ret, wbuf);

				/* close fd_pipe[1] */
				close(fd_pipe[1]);

				printf("[%d] waiting child's termination\n", pid);
				pid_temp = wait(&status);
				printf("\n");
				printf("[%d] pid %d has been terminated with status %#x\n", pid, pid_temp, status);
		}

		printf("[%d] terminted\n", pid);

		return EXIT_SUCCESS;
	}
```

### `mkfifo()`
- `int mkfifo(const char *pathname, mode_t mode)`
- 기능: FIFO(이름있는 파이프) 파일 생성
	- 이를 매개로 다른 프로세스끼리 파이프 통신 가능
- 리턴: 성공 시 0, 실패시 errno 설정 후 -1 리턴
	- 이미 파일 존재 시 errno를 EEXIST로 설정 후 -1 리턴
- pathname: 생성할 FIFO 파일 이름
- mode: 파일의 접근 권한
- FIFO 파일은 파이프로의 접근 경로에 불과: 파일의 크기가 늘거나 줄지 않음
- 어떤 프로세스가 읽기위해 파일을 열었다면, 다른 프로세스가 쓰기위한 목적으로 같은 파일을 열 때까지 대기(반대의 경우도 마찬가지)
	- 한 쪽이 읽거나 쓴다면 다른쪽이 쓰거나 읽을 때까지 대기
- FIFO파일의 권한부분에는 P라고 써져 있음: 파이프임을 의미

```bash
	root@WT4412:/mnt/nfs# ls ./my_fifo -l
	prwxr-xr-x    1 root     root             0 Nov  9  2017 ./my_fifo
```
```cpp
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <errno.h>
	#include <string.h>
	#include <fcntl.h>

	#define MAX_BUF 512
	#define PATH_FIFO "./my_fifo"

	pid_t pid;

	int main(int argc, char **argv)
	{
		int fd_fifo;
		int ret;
		char wbuf[MAX_BUF];
		int i;


		printf("[%d] running %s\n", pid = getpid(), argv[0]);
		if(argc < 2) {
				printf("[%d] usage: %s {str1} {str2} ...\n", pid, argv[0]);
				return EXIT_FAILURE;
		}
		/* make fifo */
		ret = mkfifo(PATH_FIFO, 0777);
		//파일 생성, 권한 부여
		if(ret == -1) {
			if(errno == EEXIST) {
					printf("[%d] %s already exists\n", pid, PATH_FIFO); //파일이 존재할 때
			}
			else {
					printf("[%d] error: %s\n", pid, strerror(errno)); 
					return EXIT_FAILURE; //에러
			}
		}

		/* open fifo */
		fd_fifo = open(PATH_FIFO, O_WRONLY);
		//파일 열기: 쓰기 전용
		if(fd_fifo == -1) {
				printf("[%d] error: %s\n", pid, strerror(errno));
				return EXIT_FAILURE;
		}
		/* write data to pipe */
		strcpy(wbuf, argv[1]);
		for(i=2; i<argc; i++) {
				strcat(wbuf, " ");
				strcat(wbuf, argv[i]);
		}
		ret = write(fd_fifo, wbuf, strlen(wbuf)+1);
		if(ret == -1) {
				printf("[%d] error: %s\n", pid, strerror(errno));
				return EXIT_FAILURE;
		}
		printf("[%d] wrote %d bytes to %s [%s]\n", pid, ret, PATH_FIFO, wbuf);

		close(fd_fifo);

		printf("[%d] terminted\n", pid);

		return EXIT_SUCCESS;
	}
```

### NONBLOCK
- BLOCK: 원하는 조건을 만족할 때까지 프로세스가 멈춰있는 현상
- FIFO 파일에 읽고 쓰는 프로세스들은 일반적으로 BLOCK 속성을 가지고 있음
	- 읽을 자료가 있을 떄까지 쓰기 대기, 혹은 쓰기 프로세스가 있을 때까지 읽기 대기
- NONBLOCK 속성을 부여할 때, 프로세스는 기본 조건을 만족하지 않아도 바로 종료

## 메세지 큐
### 메세지 큐
- 메세지 큐에 연결된 프로세스들은 쉽게 메세지를 보내고 받을 수 있음
	- 자신이 보낸 메세지를 자신이 받을 수도 있음
- `int msgget(key_t key, int msgflg)`
- 기능: 메세지 큐 할당
- 리턴: 성공 시 메세지 큐의 ID, 실패 시 errno 설정 후 -1 리턴
	- ID값을 통해 메세지를 제어
- key: 메세지 큐에 접근하기 위한 키
	- 이를 이용하여 서로 다른 프로세스가 같은 메세지 큐에 접근 가능
- msgflg: IPC_CREAT 사용 시 해당 메세지 큐가 없을 때 새로 생성
	- IPC_CREAT | IPC_EXCL 사용 시 해당 메세지 큐가 있으면 에러 생성
- `ipcs -l` 명령으로 현재 메세지 큐 정보 확인 가능

```bash
	user@user-VirtualBox:~$ ipcs -l
	...
	------ Messages Limits --------
	max queues system wide = 1667
	max size of message (bytes) = 8192
	//메세지가 가질 수 있는 최대 사이즈
	default max size of queue (bytes) = 16384
	//큐가 가질 수 있는 최대 사이즈
```

![message queue](https://www.cloudamqp.com/img/blog/message-queue-example.png)

출처: https://www.cloudamqp.com/blog/2014-12-03-what-is-message-queuing.html

### `msgctl()`
- `int msgctl(int msqid, int cmd, struct msqid_ds *buf);`
- 기능: 메세지 큐 제어
- 리턴: 실패 시 errno 설정 후 -1 리턴, 성공시 cmd에 따라 값이 다름
- msqid: 메세지 큐의 ID
- cmd
	- cmd가 IPC_STAT: 메세지 큐 정보를 buf에서 얻어옴
	- cmd가 IPC_RMID: 메세지 큐 완전 제거
	- 이외에도 여러 명령 존재

### msgsnd()
- `int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);`
- 기능: 메세지 큐에 메세지 보냄
- 리턴: 성공 시 0, 실패 시 errno 설정 후 -1 리턴
- msqid: 메세지 큐의 ID
- msgp: `long mtype, char mtext[64]`로 이루어진 구조체 타입
	- msgrcv()도 동일한 타입의 구조체 사용
	- mtype은 필수, 나머지는 자유롭게 정의
	- mtype은 0보다 커야 함
- msgsz: msgp가 가리키는 구조체에서 mtype의 크기(4B)를 제외한 크기
- msgflg
	- msgsnd()는 큐에 공간이 있을 경우 즉시 메세지를 보냄
	- 공간이 없을 경우 공간이 생길 때까지 대기
	- msgflg = IPC_NOWAIT일 경우 대기하지 않고 에러 리턴

### msgrcv()
- `ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg;` 
- 기능: 메세지를 받음
- 리턴: 성공 시 받은 바이트 수, 실패시 errno 설정 후 -1 리턴
- msgtyp
	- 0: 제일 먼저 들어온 메세지를 읽음
	- \> 0: mtype이 msgtyp과 같은 메세지 중 제일 먼저 들어온 자료 읽음
	- < 0: mtype이 msgtyp의 절대값보다 작은 메세지 중 가장 작은 mtype의 메세지 읽음
- 나머지는 msgsnd와 동일