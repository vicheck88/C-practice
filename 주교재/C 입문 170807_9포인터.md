# 포인터
## 개념
### 포인터의 선언
- `*`(포인터): modifier의 하나로, 주소화 시키는 역할 수행
	- `int *a`: a는 int를 가리키는 주소
	- 포인터가 가리키는 주소 안에 있는 변수의 type을 앞에 적어줌 `int *a`
	- a는 메모리에 있는 int를 가리켜야 하므로, 그 메모리 주소를 가지고 있어야 함
	- 따라서, a는 4B의 주소값을 가지고 있는 변수
	- &a가 0x1000일 경우, a라는 이름의 4B 변수가 0x1000번지에 생김
	- a값 안에 0x200이 있는 경우: a는 주소 0x200를 바라보는 것
	- 0x200번지 안에 10이 있을 경우, a는 0x200주소의 값인 10을 나타내게 됨
- 포인터 변수에서는 void 타입이 존재
	- 주소는 존재하지만, 타입의 종류를 모를 경우 사용

![포인터.png](C:\Users\student\Desktop\C-practice\주교재\image\포인터.png)

### 포인터 변수
- 포인터는 주소를 담는 변수
- 따라서, 포인터의 크기는 4B
- 주소 값만 가지고 데이터를 액세스할 수 있음
- 주소 값을 변경함으로써 다른 주소에 있는 데이터를 액세스할 수 있음

### `*` 연산자
- 다른 modifier들처럼( [ ],( ) ) 포인터를 액세스하기 위해서는 `*` 연산자가 필요
- `*` 연산자를 통해 해당 주소의 값을 이용할 수 있음
- `*` 연산자는 간접연산자, 내용참조연산자 또는 asterisk 라고 읽음
- `int *p`, p의 주소 0x1000, p의 값 0x200일 경우
	- `p=0x200, &p=0x1000, sizeof(p)=4, *p=10, sizeof(*p)=4`
- 일반 변수에 `*` 연산자를 붙일 수는 없음: 포인터 변수(주소 타입)에게만 붙일 수 있음
	- `int a=100`일때, `*a`식의 표현은 불가
- 포인터는 주소 값을 통해 간접적으로 변수에 접근하므로, `*`를 간접 연산자라고도 부름

### 포인터 변수의 연산
- 포인터 변수 역시 연산이 가능하지만, 일반적인 연산과는 다름
	- `int *p`를 선언할 경우
	- `p = 0x0012ff68`일 때, `p+1 = 0x0012ff6c, p-1 = 0x0012ff64`
	- 포인터 변수가 가리키는 변수의 타입의 바이트수만큼 증가, 감소함
	- `char *p`라면, char의 크기로 인해 `p+1 = 0x0012ff69, p-1 = 0x0012ff67`

```cpp
void main(void)
{
	int a = 100;
	int *p;
	p = &a;
	printf("%#.8x %#.8x\n", p, &a);  //0x004bfc40
	printf("%#.8x %#.8x\n", *p, a);
	printf("%#.8x %#.8x\n", p+1, p-1); //01004bfc44,0x004bfc38
	printf("%#.8x %#.8x\n", *(p+1), *(p-1)); //쓰레기값이 나타남
}
```

### 포인터의 활용
- Heap이라는 공간을 활용하는 데에 포인터가 필요: Heap은 주소를 사용해야함
- 이를 통해 배열을 동적으로 할당하는 등의 행위가 가능
- 하드웨어의 제어를 위한 메모리 액세스에 사용
- Call by address: 주소값을 넘겨받아 함수를 수행
	- call by value와는 달리 변수의 값을 변경 가능

```cpp
void f1(int a)
{
	a=200;
    printf("%d\n",a);
}
void f2(int *p)
{
	*p=200;
    printf("%d\n",*p);
}

void main(void)
{
	int a=100;
    f1(a); printf("%d\n",a); // 200,100을 출력(call by value)
    f2(&a); printf("%d\n",a); // 200,200을 출력(call by address)
}
```

## 배열과 포인터
### `[ ]`와 `*`
- 배열 `a`는 배열의 첫 요소의 주소(`&a[0]`)을 가리킴
- 따라서, `a+1 = &a[0]+1`이 성립: 요소의 타입이 차지하는 주소만큼 이동
- `&a+1`은 배열 전체가 차지하는 범위만큼 이동
- 배열의 요소들은 메모리에 연속적으로 저장되어 있음
- 이때, `a[0],a[1]` 등 뿐 아니라 `a[-1]` 등의 요소 역시 접근 가능
	- `&a[-1] == &a[0]-1 == a-1`
- 배열요소의 주소를 포인터로 잡을 경우, 요소의 타입을 지정하면 됨
- 배열은 주소를 가지고 있으므로 배열요소를 포인터를 통해 접근 가능
	- `*a == a[0], *(a+1) == a[1]...`
- 일반화하여 `a[i] == *(a+i)` 성립

```cpp
void main(void)
{
	int a[4] = { 0, 1, 2, 3 };
	printf("%#.8x, %#.8x,%#.8x\n", &a, &a[0], a); //같은 값
	printf("%#.8x, %#.8x,%#.8x\n", &a+1, &a-1, a);
    // &a+1의 주소값은 a의 주소값+16B: a의 주소가 0x10000000일 때,
    // &a+1의 주소는 0x10000010. &a-1의 주소는 0x0ffffff0
}
```

### `&` 붙인 데이터의 타입
- `int x`가 있을 때, `&x`의 타입은 `int *`
- `*` 연산자는 `int *` 등의 타입의 변수에만 적용 가능
- `*&x == x`: x가 속한 주소의 값을 출력: 결국 x값 출력
- `int a[4]`가 있을 때
	- a의 타입은 `int [4]`이면서 (배열을 나타냄) `int *` (a는 첫번째 요소의 주소를 가지고 있음): 양면성을 가지고 있음
	- 이때, `a`는 `a[0]`의 주소이므로 `int *` 타입이고 `&a`는 배열 `a`의 주소로 작용, `int (*) [4]` 타입이 됨
	- `sizeof, &`연산자에서 `a`는 배열로 인식되며, 그 외의 모든 나머지 부분에서 주소(`&a[0]`)로 사용됨
	- `&a`를 포인터로 잡을 때: `int (*p)[4]=&a`
		- 괄호가 없을 경우, 뒤의 [4]가 먼저 작용하여 p는 배열로 인식됨
		- `int *p[4] == int *(p[4])`: 주소를 네 개 저장하는 포인터 생성
	- 이 경우, `*` modifier는 무한히 적용 가능

### 포인터와 배열
- `int a[4]`이고 `int *p = a`일 경우, `*(p+i)==p[i]`로 표현 가능
- 함수로 사용할 때 배열을 parameter로 적용할 경우, 컴파일러가 알아서 `int *`꼴로 변환: sizeof 명령어가 잘 먹지 않는다
- 함수에서 배열을 넘길 경우, 단독으로 요소수를 알 수 있는 방법은 없음: C의 한계
	- 요소수를 알려주는 int parameter를 하나 더 추가함으로써 요소수를 직접 알려줘야

```cpp
int sum1(int a[10]) // 원칙적으로 옳지 않으며, int *표현을 사용해야함 (int sum(int *a))
{
	int i, s = 0;
	for (i = 0; i < 10; i++)
	{
		s += a[i];
	}
	return s;
}
int sum2(int a[10])
{
	int i, s = 0;
	for (i = 0; i < sizeof(a)/sizeof(a[0]); i++)
    //sizeof(a)=4: 변수를 int *로 변경하므로 a는 4B
	{
		s += a[i];
	}
	return s;
}

void main(void)
{
	int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int r;
	r = sum1(a);
	printf("SUM1 = %d\n", r); // SUM1 = 55

	r = sum2(a);
	printf("SUM2 = %d\n", r); // SUM2 = 1
}
```
```cpp
int sum(int num, int *p) //int는 요소수를 알려주는 parameter
{
	int i, s =0;

	for(i = 0; i < num; i++)
	{
		s += p[i];
	}

	return s;
}

void main(void)
{
	int a[10] = {1,2,3,4,5,6,7,8,9,10};
	int r;

	r = sum(sizeof(a)/sizeof(a[0]), a);
	printf("SUM = %d\n", r);

	r = sum(5, a);
	printf("SUM = %d\n", r);
}
```

### 배열 리턴 함수
- 배열 그 자체를 리턴하는 것은 불가능
- 배열을 리턴하고자 할 때는, 포인터를 사용해야만 함

```cpp
int * func(void) //포인터를 리턴하는 함수
{
	static int a[4] = {10, 20, 30, 40};
    //static이 아니라면 함수가 종료될 때 변수 역시 사라지게 됨
    //따라서, 반드시 static이어야 함

	return a; //배열 a의 주소
}

void main(void)
{
	int i;
	int *p;

	p = func();

	for(i = 0; i < 4; i++)
	{
		printf("%d\n", p[i]);
	}
}
```
### 문자열과 포인터
- 문자열 역시 주소: 포인터로 표현 가능
- 문자열은 입력과 동시에 주소가 할당됨: 자신의 지정석이 존재
- 메모리 중 text를 보관하는 부분에 문자열 배치: 절대번지로 static memory에 저장됨
- 문자열은 읽기전용 메모리(RO: Read only)에 저장되며, 코드 역시 같은 부분에 저장됨
- 따라서, RO data에 있는 문자열에 액세스할 경우, 문자의 수정이 불가능
- 함수로 활용할 때처럼 `char *p`를 parameter로 사용해야함

```cpp
void main(void)
{
	char *p = "Hello";
	printf("%s\n", p); // Hello
	printf("%s\n", p+1); // ello
	printf("%c\n", *p); // H
	printf("%c\n", *(p+1)); // e
}
```
```cpp
void main(void)
{
	char *q;
	char *p="Hello"; // RO 영역의 static memory 자료가 있는 주소에 직접 액세스
    char a[6]="Hello"; // RO 영역의 문자열을 stack에 복사
    q="Hello" // 이경우, p와 q는 같은 주소를 공유하게 됨
    //(완전히 같은 문자열의 경우, RO 영역에서 두번 만들지 않고 서로 공유하게 됨)
}
```

