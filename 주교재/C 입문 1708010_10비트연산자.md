# 비트 연산자
## 비트 연산자 이해
### 비트 연산자의 종류
- 비트 연산자는 비트 단위로 연산을 할 수 있도록 하는 연산자를 일컬음
- 메모리의 일부분의 값을 고칠 때 사용하는 연산자
- 비트 단위로 계산을 수행하므로 메모리를 많이 절약할 수 있고 속도가 빠름
- 종류
	- `&`(and) : 0을 입력하여 원하는 비트들만 0으로 만듦 (bit clear)
	- `|`(or) : 1을 입력하여 원하는 비트들만 1로 만듦 (bit set)
	- `^`(xor) : 원하는 비트들만 원래 값 반전 (bit invert)
	- `>>`(shift right) : 메모리를 오른쪽으로 비트 수 만큼 이동
	- `<<`(shift left) : 메모리를 왼쪽으로 비트 수 만큼 이동
	- `~`(bit invert) : 메모리의 전체 비트 반전 (`!` 연산자와는 다름)

### 일반 논리 연산자와의 차이
- `&&,||,!` 연산자들은 논리(참, 거짓)을 다루며 비트 연산자(`&,|,~,^`)는 비트만을 다룸
- 비트연산자는 하나의 비트에 대해 논리연산을 한다고 생각하면 됨

![진리표.jpg](.\image\진리표2.jpg)

```cpp
void main(void)
{
	int a = 0x55aa33cc; //0101 0101 1010 1010 0011 0011 1100 1100
	int b = 0x0f0f0f0f; //0000 1111 0000 1111 0000 1111 0000 1111
	printf("a & b = %#.8X\n", a&b); // 0x50A030C
	printf("a | b = %#.8X\n", a|b); // 0x5FAF3FCF
	printf("a ^ b = %#.8X\n", a^b); // 0x5AA53CC3
	printf("~a = %#.8X\n", ~a); // 0xAA55CC33
}
```

### 중복 사용
- `&` 연산자의 경우, clear하기 원하는 부분에 0을 대입: 값을 계산하는 것이 어려움
- `~` 연산자와 함께 사용할 경우, 원하는 부분에 1, 나머지에 0을 넣으면 되므로 계산이 쉬움
- 이처럼, 연산자를 중복 사용하여 좀 더 쉽게 원하는 결과를 얻을 수 있음
- 또한, set과 clear를 동시에 수행할 때 사용하게 됨

```cpp
void main(void)
{
	int a = 0x55AA33CC;
	int b, c, d;

	b = a | 0x08000C11;
	c = a & ~(0x400200C) ; // ~을 사용하지 않을 경우, 0xBFFFDFF3으로 대입해야
	d = a ^ 0x0400C1C1;

	printf("b = %#.8X\n", b);
	printf("c = %#.8X\n", c);
	printf("d = %#.8X\n", d);
}
```

### 비트 shift 연산
- shift 연산은 좌(`<<`), 혹은 우(`>>`)로 비트를 원하는 만큼 움직이는 연산
- shift 연산은 곱하기, 나누기로 사용하는 것이 가능
	- `<<` 연산을 수행할 경우, 한번 수행할 때마다 2가 곱해짐
	- `>>` 연산을 수행할 경우, 한번 수행할 때마다 2가 나누어진 결과와 비슷(int에서의 /2와 같음)

### 두 종류의 shift연산: 논리적, 산술적 shift
- 일반적으로 unsigned int는 logical, signed int는 arithmetic shift를 수행
- signed int 형식의 shift 방식은 컴파일러마다 방식이 다름: unsigned int로 캐스팅하여 작업을 수행하는 것이 안전
||논리적: 부호를 고려하지 않음|산술적: 부호를 고려|
|---|---|---|
|`>>`|MSB가 0이 됨|부호비트(MSB)는 바뀌지 않음|
|`<<`|MSB가 밀려나감|부호비트(MSB)도 밀려남|

## 비트 연산자 활용
### 비트 set 구문
```cpp
void bdisp(int a) // 정수를 이진법으로 출력하는 함수
{
	int i;

	for(i = 31; i >= 0; i--)
	{
		printf("%d", ((unsigned int)a >> i) & 1);
		if((i%4 == 0) && (i != 0)) printf("_");
	}
	printf("\n");
}

void main(void)
{
	int a = 0x33cc55aa;

	a |= 0x08000389;
	bdisp(a);

	a = 0x33cc55aa;
	a |= (1<<27)|(1<<9)|(1<<8)|(1<<7)|(1<<3)|(1<<0);
    // set하기 원하는 비트들을 골라 shift연산을 통해 계산할 수 있음
	bdisp(a);

	a = 0x33cc55aa;
	a |= (1<<27)|(0x7<<7) |(1<<3)|(1<<0); 
    // 9,8,7비트에 전부 일을 대입: 0x7로 생각 가능
	bdisp(a);
}
```
### 비트 invert, clear 구문
- 원하는 부분의 비트를 반전시킬 때는 `^` 연산 이용
- clear 구문은 `&`와 `~`를 복합적으로 사용하여 구문을 편리하게 바꿈

```cpp
void main(void) // 비트 invert
{
	int a = 0x33cc55aa;

	a ^= 0x08000389;
	bdisp(a);

	a = 0x33cc55aa;
	a ^= (1<<27)|(1<<9)|(1<<8)|(1<<7)|(1<<3)|(1<<0);
	bdisp(a);

	a = 0x33cc55aa;
	a ^= (1<<27)|(0x7<<7) |(1<<3)|(1<<0); 
	bdisp(a);
    
    int a = 0x33cc55aa; // 비트 clear
    
	a = 0x33cc55aa;
	a &= ~0x08000389;
	bdisp(a);

	a = 0x33cc55aa;
	a &= ~((1<<27)|(1<<9)|(1<<8)|(1<<7)|(1<<3)|(1<<0));
	bdisp(a);

	a = 0x33cc55aa;
	a &= ~((1<<27)|(0x7<<7) |(1<<3)|(1<<0)); 
	bdisp(a);

	a = 0x33cc55aa;
	a &= ~(1<<27)|(0x7<<7) |(1<<3)|(1<<0); 
	bdisp(a);
}
```
