# 배열 등가포인터와 양파이론
## 2차원 배열과 배열 등가포인터
### 다차원 배열의 재해석
- 2차원 배열은 `int[2][3]={{1,2,3},{4,5,6}}` 식으로 초기화
- 2차원 배열은 배열 안에 배열이 들어있는 구조로 해석 가능
- 따라서, 위의 예에서의 요소수는 2개: 각 요소의 요소수는 3

### 2차원 배열의 초기화
- 1차원 배열의 경우, 요소수를 생략하는 것이 가능
	- `int a[]={1,2,3,4}`
- 2차원 배열의 경우에도 마찬가지로 요소수의 생략이 가능
	- `int a[2][3]`의 요소는 앞의 2(첫번째 요소수)에 해당
	- 따라서 `int a[][3]`의 형식으로 초기화하는 것이 가능
	- 요소의 요소수를 생략할 수는 없음: 여기에서는 배열 요소의 요소수
	- `int a[2][]`식의 생략은 불가
- 일반적인 다차원 배열로 확장하는 것이 가능

### 2차원 배열의 함수 전달
```cpp
//void prt_array(int b[3][4])
//void prt_array(int b[ ][4])
//void prt_array(int b[3][ ]) //오류
//void prt_array(int b[ ][ ]) //오류
//void prt_array(int b[4][4])
//void prt_array(int b[3][3]) //작동하지만 타입이 달라 제대로 작동하지 않음
//void prt_array(int b[4][3]) //작동하지만 타입이 달라 제대로 작동하지 않음
{
	int i, j;

	for(i=0; i<3; i++)
	{
		for(j=0; j<4; j++) printf("b[%d][%d]=%d\n", i, j, b[i][j]);
	}
}
void main(void)
{
	int a[3][4] = {{10,20,30,40},{50,60,70,80},{90,100,110,120}};
    //parameter가 실제로 받은 타입은 int (*)[4]
	//타입에 맞춰 함수의 prototype을 설정해야
	prt_array(a);
}

```

### 2차원 배열의 분석
- 2차원 배열은 자기 이름의 깡통을 가지고 있는 구조
- `a`라는 이름의 깡통이 있고 그 안에 2차원 배열을 가지고 있음
- 그런데 2차원 배열 안에 다시 배열이 들어가 있음. 즉, 이중 깡통 구조
- 환원식: `*`과 `[]`를 반복하여 알기 쉽게 수식을 변화시킴
	- `int a[3][4] == *(a[2]+3) == *(*(a+2)+3)`
	- 일반화: `a[m][n] == *(*(a+m)+n)`: 교환법칙 성립
	- 때문에 `3[2[a]]` 같은 표현도 가능
- 2차원 배열의 주소는 1차원때와 비슷하게 적용 가능
	- `a[0]` 타입: `int [4] (int *)`
	- `a` 타입: `int [3][4] (int (*)[4])`
	- `&a` 타입: `int (*)[3][4]`



### 배열 등가 포인터
- 배열이 불가능한 것을 대신해주는 포인터
- 함수의 parameter, return으로서 배열을 사용하고자 할 때, 배열 대신 넣음으로써 역할을 대신
- 배열을 대입할 때 경고가 발생하지 않아야 함
- `void *`는 등가 포인터가 될 수 없으며, 정의식 `a == &a[0]`에서 `&a[0]` 타입의 포인터를 만듦

```cpp
void draw_pixel(int y, int x, int value,  int *p)
{
	p[y*3+x] = value; //2차원 배열을 1차원처럼 인식하게 됨: 경고
}

void draw_pixel(int y, int x, int value,  int (*p)[3])
//다음과 같은 방식으로 포인터를 이용해야 함(등가 포인터)
{
	p[y][x] = value;
}

void main(void)
{
	int a[2][3] = {1,2,3,4,5,6};

	printf("%d\n", a[1][2]);
	draw_pixel(1, 2, 10, a);
	printf("%d\n", a[1][2]);
}
```
```cpp
int (*func(void))[4] 
{
	static int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
	return a; //배열을 리턴할 때: 배열 등가 포인터
}

void main(void)
{
	printf("%d\n", func()[1][2]);
}
```
```cpp
void main(void)
{
	int a[2][3][4];
	int (*b[3])[4];
	int *(*c[2])(int *);
	int *d[3][4];
	int (*(*e[5])(void))[4];

	// pa ~ pe 포인터 변수 선언
	// 아래에 pa ~ pe 까지 포인터를 선언한다
	// pa ~ pe는 a ~ e의 등가포인터에 해당(연산 수행 때 경고가 일어나지 않음)

	int (*pa)[3][4];
	int (**pb)[4];
	int *(**pc)(int *);
	int *(*pd)[4];
	int (*(**pe)(void))[4];

	pa = a;
	pb = b;
	pc = c;
	pd = d;
	pe = e;
}
```

### `void *`
- `void *`는 아무 타입의 포인터와도 대입이 가능한 포인터
- 코드의 신뢰성이 저해되므로 필요한 경우에만 사용
- `void *`로 대입이 발생할 때 대치법의 적용이 불가능
- `void *`는 다음과 같을 때 사용
	- 함수의 리턴을 어떤 포인터 타입이 대입 받을지 모를 때
		- `int *ip=malloc();`
	- 함수를 호출할 때 어떤 타입의 주소를 전달할 지 알 수 없을 때

```cpp
int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};

int func(void * p, int a, int x)
{
	int (*q)[4] = p; //반드시 형변환하여 사용
	return (a+2)[q[x-1]]; //(1+2)[q[1]] == 3[a[1]] == a[1][3] == 8
}

void main(void)
{
	printf("%d\n", func(a, 1, 2));
}
```

### 메모리는 변함 없다

```cpp
int a[12] = {10,20,30,40,50,60,70,80,11,22,33,44};

void main(void)
{
	int *p = a; 
	char * q = (char *)a;
	int (*r)[4] = (int (*)[4])a;
	int (*s)[3] = (int (*)[3])a;
	int (*t)[2][3] = (int (*)[2][3])a;

	//메모리 값 자체는 변함이 없으나 이를 인식하는 포인터의 타입이 달라짐
    //+1의 의미가 변화하며 따라서 다음 값의 주소를 얻을 때 구하는 값이 달라짐
	printf("%d, %d\n", p[0], p[1]); //10,20
	printf("%d, %d\n", q[0], q[1]); //10,0
	printf("%#.8x, %#.8x\n", r[0], r[1]); //0x1000,0x1010
	printf("%#.8x, %#.8x\n", s[0], s[1]); //0x1000,0x100c
	printf("%#.8x, %#.8x\n", t[0], t[1]); //0x1000,0x1018
}
```

## 환산법과 양파이론
### 배열의 가중치와 환산법
- `a[n] == *(a+n)`의 개념을 이용할 때, 배열의 요소들을 여러가지의 형태로 나타낼 수 있음
- 이때, 배열에는 가중치의 개념이 존재
	- `int a[2][3][4]` 배열에서
    - `[4]`는 `int` 요소를 가짐: 가중치는 `int` 1개
    - `[3]`는 `int[4]` 요소를 가짐: 가중치는 `int[4]` 1개 == `int` 4개
    - `[2]`는 `int[3][4]` 요소를 가짐: 가중치는 `int[3][4]` 1개 == `int[4]` 3개 == `int` 12개
- 가중치를 이용하여 배열의 요소들을 마음대로 변환하는 것이 가능(환산법)
	- `int a[3][4]` 배열에서
	- `a[2][3] == a[1][7] == a[0][11]`
	- `a[1][2] == a[0][6] == a[-1][10]`

```cpp
int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
int b[3][4];

void array_copy(int * dest, int * src, int num)
{
	while(num--) *dest++=*src++;
}

void main(void)
{
	int i, j;

	array_copy((int *)b, (int *)a, (sizeof(a)/sizeof(a[0]))*(sizeof(a[0])/sizeof(a[0][0])));
	//2차원 배열을 강제로 1차원 배열로 인식하여 복사
	//2차원 배열 그대로 복사하는 것보다 속도가 빠름
	for(i=0; i< sizeof(a)/sizeof(a[0]); i++)
	{
		for(j=0; j< sizeof(a[0])/sizeof(a[0][0]); j++)
		{
			printf("[%d][%d]=%d,%d\n", i, j, a[i][j], b[i][j]);
		}
	}
}
```

### `*`: modifier vs 연산자
- 변수에 `*` modifier가 추가될 때는 주소의 겹 수가 증가: 주소의 다중화
- 변수에 `&` 연산을 추가할 경우에도 주소의 겹 수가 증가: 주소의 다중화
- 변수에 `*` 연산자를 추가할 경우, 주소가 한겹 벗겨짐: 주소의 역다중화
- 주소타입에 덧셈, 뺄셈 연산자가 적용될 경우 원래 주소의 타입이 승계되어 연산 이전, 이후의 타입이 동일
- 선언된 변수와 수식을 보면 몇 겹의 타입인지를 알 수 있음

### `[]`: modifier vs 연산자
- `[]` 연산자, modifier는 `*`연산자와 동일한 작업 수행
	- modifier: 주소의 다중화, 연산자: 주소의 역다중화
- 데이터 타입이 배열일 경우, 주소 타입을 함께 구할 필요가 있음(양면성)

### 양파이론
- `*,[]` modifier는 주소의 겹을 늘리고, `*,[]` 연산자는 주소를 벗김
- 주소는 양파껍질처럼 늘어나며, 벗길 때는 무조건 바깥 껍질부터 벗겨짐
- 1순위 modifier가 가장 바깥 껍질이며, 제거시 1순위부터 제거됨

### 가상의 배열을 이용한 수식의 계산
- 쉽게 알 수 없는 변수의 타입을 구할 때는 `[]`을 이용한 배열 형식으로 만들어 쉽게 구할 수 있음
	- `*`와 `[]` 연산자의 관계를 이용하여 가상의 배열을 생성
	- 생성한 가상의 배열을 바탕으로 modifier들을 겉에서부터 제거
	- 이때, 변수의 타입을 지속적으로 확인하면서 문제를 해결해야함

```cpp
int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};

int func(void * p, int a, int x)
{
	int (*q)[4] = p;
	return (a+4)[q[x-1]]; //a[1][4]=a[0][9]와 같음
}

void main(void)
{
	printf("%d\n", func(a, 1, 2));
}
```

### 함수의 parameter, 리턴 타입 설계
```cpp
int a[2][3][4] = {{{1,2,3,4},{5,6,7,8},{9,10,11,12}},{{10,20,30,40},{50,60,70,80},{90,100,110,120}}};

void f1( int *p  ) 
{
	printf("%d\n", p[17] );
}

void f2( int (*p)[4] )  
{
	printf("%d\n", p[-1][1]);
}

void f3( int (*p)[3][4] ) 
{
	printf("%d\n",  p[1][2][1]);
}

void f4( int (*p)[3][4] ) 
{
	printf("%d\n",  p[-2][2][1] );
}

void f5( int (*p)[2][3][4] ) 
{
	printf("%d\n", p[0][1][2][1] );
}

void f6( int (*p)[2][3][4] ) 
{
	printf("%d\n", p[1][1][2][1] );
}

void main(void)
{
	f1(*(a[0]+1));  
	f2(*(a+2));
	f3(a);
	f4(a+3);
	f5(&a);
	f6(&a-1);
}
```
```cpp
int a[2][3] = {{1,2,3},{4,5,6}};
int b[2][3] = {{10,20,30},{40,50,60}};
int (*c[2])[3] = {b, a};
int (**p)[3] = c;

int (*f1(void))[3] 
{
	return c[1];	
}

int (**f2(void))[3]  
{
	return c+1;
}

int *f3(void) 
{
	return a[0]-1;
}

int (**f4(void))[3] 
{
	return p;
}

int (*(*f5(void))[2])[3] 
{
	return &c;
}

void main(void)
{
	printf("6=%d\n", f1()[1][2]);
	printf("6=%d\n", f2()[0][1][2]);
	printf("6=%d\n", f3()[6]);
	printf("6=%d\n", f4()[1][1][2]);
	printf("6=%d\n", f5()[0][1][1][2]);
}
```