# 깡통이론과 포인터 활용
## 깡통이론

# 날라간 파일 복구할 것



### 오류 메세지의 인쇄
- 프로그램 중간 상황에 따라 상황을 판단하고 그에 따른 메세지를 출력할 때, 종류별로 배열에 모아놓고 인쇄 내용을 선택하여 출력하면 반복되는 문제나 메세지를 편집할 때 유리
- 인쇄 메세지들을 한 군데 모아놓은 버퍼를 string pool이라고 부름

```cpp
char err[3][25] = {"Speed Error!", "Position Error!", "Unknown Command Error!"};

//배열 안 문자열을 1차원 배열로 저장
//주소를 찾아갈 필요없이 바로 출력이 가능하므로 속도측면에서 유리하고 편집이 가능한 데 반해, 메모리 측면에서는 불리

void main(void) 
{
	printf("%s\n", 	err[1]);
}
```

```cpp
char *err[3] = {"Speed Error!", "Position Error!", "Unknown Command Error!"};

//배열 안에 RO영역에 속한 문자열의 시작주소를 저장
//메모리를 따로 할당할 필요없어 유리하지만, 한번 더 액세스를 해야 문자열에 접근 가능하므로 속도 측면에서 불리하며 편집이 불가능

void main(void) 
{
	printf("%s\n", 	err[1]);
}
```

### 문자열과 `char` 배열
- 문자열은 RO 데이터에 위치하며, 따라서 편집이 불가
- RO 데이터 안의 문자열은 유일하며, 같은 문자열을 쓸 때 같은 주소를 공유
- 문자열은 그 자체가 이름: 이름 자체가 이름인 `char` 배열이 문자열
- `char` 배열은 RO데이터에 위치한 문자열을 배열에 복사하여 작업 수행

```cpp
void main(void)
{
	char a[4] = "LEW";

	printf("%X	%X \n", a, &a); //스택 부분에 위치
	printf("%X	%X \n", "LEW", &"LEW"); //RO영역에 위치: 저장 위치가 다름
	printf("%c	%c\n", a[0], a[1]);
	printf("%c	%c\n", "LEW"[0], "LEW"[1]);
	printf("%c	%c \n", *a, *(a+1));
	printf("%c	%c \n", *"LEW", *("LEW"+1));
	printf("%X	%X \n", "LEW", "LEW"+1);
	printf("%X	%X \n", a, a+1);
}
```
```cpp
void main(void)
{
	char a[ ] = "Motel";
	char *p   = "Motel";

	a[0] = 'H';
	p[0] = 'H';
    
    //에러 발생: RO 데이터는 편집 불가
    //하드웨어에서(memeory protection unit)에서 감지, 예외처리함

	printf("%s\n", a);
	printf("%s\n", p);
}
```

### 문자열과 `%s` 포맷 지시자
- `%s`는 문자열을 출력
- 이때, 출력하고자 하는 문자열의 주소를 입력받으며, 널문자를 만날 때까지 출력

```cpp
void main(void)
{
	char a[ ] = "LEW";
	char *p = "%s\n";

	printf("%s\n", "LEW");
	printf("%s\n", a);
	printf("%s\n", *a); //문제 발생: %s는 문자열 주소를 받아야함
	printf(p, a); 
    //잘 작동: "%s\n"역시 문자열이며, 자신의 주소를 가지고 있음
    //p가 가리키는 값은 "%s\n" 문자열 자체로 결국 둘은 같은 값을 의미
}
```

### 문자열 깡통
- 문자열은 자기 이름의 깡통을 가지고 그 안에 문자열을 넣은 상태로 이해 가능
- 문자열은 이름 없는 `char[]`이며 이름이 없어 문자열 자체를 이름으로 사용
	- 배열이므로, 배열이 가지는 성질들을 그대로 가지고 있음
	- 상수이고 RO 데이터에 있으므로, 배열 안 요소들을 수정할 수 없음

```cpp
char * day(int n)
{
	return "SUN\0MON\0TUE\0WED\0THU\0FRI\0SAT\0" + (n * 4);
}
//문자열 자체가 이름없는 char[] 배열이므로, 함수의 리턴값은 어떤 char * 타입 p에 대해 p+(n*4)를 구한 값과 동일: 널값을 만날 때까지 문자 출력

void main(void)
{
	int i;
	for(i=0; i<7; i++) printf("%s\n", day(i));
    //요일을 찍음
}
```

### 함수 깡통
- 함수명이 곧 함수 주소(`func == &func`)
- 위의 등식이 함수명의 정의식이며, 따라서 함수와 함수명은 값과 타입이 일치
- `int add(int, int)`가 있을 때, 함수의 타입은 `int (int,int)`이며 함수명의 타입은 `&add`의 타입: `int (*)(int,int)`
- 실제로 함수가 쓰일 때는 `int (*)(int,int)` 타입으로 쓰임
- 다른 형식과 마찬가지로 `&add`는 상수이고, 따라서 `&&add`는 에러메세지 출력

```cpp
int add(int a, int b)
{
	return a+b;
}

void main(void)
{
	printf("%d\n", add(3,4));
	printf("%d\n", (&add)(3,4));
	printf("%d\n", (*add)(3,4));
    //정의식에 의해 *add == *(&add) == add
	printf("%d\n", (**add)(3,4));
    //**add == **&add == *add == *&add == add
}
```

## 포인터 깡통의 활용
### 포인터 깡통
- 포인터 깡통은 배열, 문자열, 함수와 달리 가리키는 대상이 깡통
- 깡통 안에 가리키는 대상이 들어 있는 구조
- 모든 포인터 `p`가 가리키는 것은 `(*p)`: 괄호가 반드시 있어야 함
	- `double *p`: `p`가 가리키는 것은 `(*p)`
- 모든 포인터 `p`가 가리키는 대상의 타입: 전체 선언에서 `(*p)`를 제외
	- `double *p`: `p`가 가리키는 대상의 타입은 `double`

```cpp
void func(int (*p)[4])
{
	// main의 a[2]를 50으로
    (*p)[2] = 50; 
    //p가 가리키는 대상의 타입은 int[4]이므로, (*p)의 타입은 int[4]
}
void main(void)
{
	int a[4] = {10,20,30,40};
	
	printf("%d\n", a[2]);	
	func(&a);
	printf("%d\n", a[2]);
}
```

### 포인터 타입 캐스팅
- 타입 캐스팅으로 이용하여 많은 기능들의 구현이 가능
	- 타입과 무관한 주소 값을 강제로 대입할 때 원하는 타입으로 캐스팅하여 포인터 변수에 입력

```cpp
int *p: p = (int *)0x1000;
int (*p)[4]: p = (int(*)[4])0x1000;
char *(*p)[2]: p = (char *(*)[2])0x1000;
int (*p)(void): p = (int(*)(void))0x1000;
```

### 배열, 문자열, 함수, 포인터 정리
- 네가지 전부 선언하자마자 주소인 타입
- 배열
	- 정의식: `a == &a[0]`. 배열과 포인터로서의 양면성이 있으며 `&,sizeof` 연산자와 쓰일 때만 배열 타입으로 쓰임
- 문자열
	- 문자열 자체가 배열의 이름인 `char []`로 배열과 동일. 단, 쓰기 금지
- 함수
	- 정의식: `fucn == &func`. 함수와 포인터로서의 양면성이 존재하며 `&,sizeof` 연산자와 쓰일 때만 함수 타입으로 쓰임
- 포인터
	- 유일하게 좌변값으로 사용 가능.
	- +1 연산 수행시 가리키는 대상의 크기만큼 증가
	- 포인터 자체의 타입은 `p`를 제외한 타입이며, 가리키는 대상의 타입은 `(*p)`를 제외한 타입
	- 불가능(배열의 요소를 함수로, 함수의 리턴값을 배열,함수로)을 가능하게 해줌(등가 포인터)

### 구조체
- 구조체는 이형의 데이터를 집합으로 만듦
- 기본형 변수로, 구조체 변수 이름이 주소를 저장하지는 않음
	- 구조체 변수 이름을 출력할 때, 구조체에 저장되어있는 가장 위의 자료들에서부터 원하는 바이트수만큼을 출력(컴파일러마다 해석이 달라짐): 이상한 결과가 나올 수 있음
- 기본형 변수이므로 함수로 넘기는 것이 가능하며, 이 경우 call by value가 되어 구조체를 복사하여 작업 수행
	- 메모리, 속도 측면에서 불리
- 때문에 주로 `&x`를 넘겨 call by address 방식을 사용





