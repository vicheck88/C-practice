# 구조체
## 구조체
### 정의
- 타입이 다른 변수들의 집합 (이종 변수 집합)
- 관련있지만 타입은 다른 변수들을 하나로 묶어 사용할 때 사용하는 타입
- `struct {멤버목록} 변수명;` 형식으로 선언
- 구조체에 속한 변수들을 멤버(member)라고 부르며, struct 블록 안에 일반 변수를 선언할 때처럼 선언
- 멤버의 타입에는 제한이 없으며, 배열, 포인터, 구조체 역시 포함 가능

```cpp
struct{
	char name[10];
    int age;
    double height;
} friend; // struct 변수 friend 선언
```

### 구조체 태그
- 일반적으로 태그를 선언한 뒤, 이를 바탕으로 구조체를 구성
- 구조체 태그는 타입에 대해 이름을 붙이는 것
- `struct 태그명 {멤버목록};` 형식
- 태그명은 명칭 규칙에만 맞다면 자유롭게 이름을 붙일 수 있음
- 태그 선언문은 컴파일러에게 구조체의 모양을 알려주는 역할을 하며, 태그를 위해 메모리를 할당하고나 변수를 생성하는 일은 없음
- 태그는 중복선언하여도 상관 없음
- `typedef`문을 사용할 경우, 태그를 정의하는 것과 동일한 효과를 낼 수 있음

```cpp
struct tag_Friend{
	char name[10];
    int age;
    double height;
} ;
struct tag_Friend Friend; 
// 태그선언이 되어있을 경우, 태그명을 통해 간단히 구조체 변수를 만들 수 있음
```

- `typedef`문을 이용하거나 태그를 이용할 경우 여러가지 편리한 점이 있음
	1. 타입이 정의될 경우, 이를 통해 같은 형의 변수를 여러개 생성 가능
	2. 해당 타입으로부터 파생되는 유도형 변수를 선언할 수 있음: 포인터, 배열 등
	3. 구조체를 함수의 인수, 리턴값으로 활용 가능

## 멤버의 참조
### 멤버 연산자
- 구조체에서는 `.` 연산자를 통해 멤버 자료에 접근할 수 있음
- `Tag_Friend.Name` 형식
- 멤버는 일반 변수와 동일한 자격을 가지고 있음
- 구조체 안이 아니라면, 멤버들의 이름은 같아도 상관없음

### 포인터 멤버 연산자
- 구조체에 대한 포인터 선언의 형식은 다음과 같음
	- `tag_Friend *pFriend; pFriend=&Friend;`
- 포인터가 가리키는 구조체의 멤버는 다음과 같이 표현
	- `(*pFriend).Age=20;`
	- `*`연산자보다 `.` 연산자가 더 우선이므로, 괄호는 생략할 수 없음
	- `->` 연산자를 이용할 수도 있음: `pFriend->Age`

### 구조체 배열
- 구조체 배열의 선언은 일반적인 배열 선언의 방법과 동일
- 반대로, 배열을 구조체의 멤버로 설정하는 것 또한 가능

### 중첩 구조체
- 다른 구조체를 멤버로 포함하는 구조체
```cpp
struct tag_A {};
struct tag_B
{
	...
    tag_A A; //구조체 B의 멤버로 구조체 A를 포함
} B;
```
- 자기 자신을 중첩하거나, 서로 다른 두 개의 구조체를 상호 중첩하는 행위는 불가능: 수행을 위해선 무한대의 메모리가 필요함
- 대신, 자신과 같은 구조체에 대한 포인터를 멤버로 받아들이는 것은 가능: 메모리의 크기가 4B로 제한되어 있음

## 구조체의 초기화
### 대입
- 배열과 달리 구조체에서는 대입이 허용됨: 한 구조체 변수의 멤버들을 같은 구조체 다른 변수에 그대로 대입할 수 있음
``` cpp
tag_Friend Friend1;
tag_Friend Friend2;
Friend2=Friend1;
	```
- 컴파일러는 배열과 달리 구조체의 이름을 좌변값으로 인정하기 때문에 다음과 같은 대입이 가능
- 대입이 가능하기 때문에 함수의 인수, 리턴값으로 사용 가능

### 깊은 복사
- 구조체의 멤버로 포인터가 있을 경우, 대입이 제대로 이루어지지 않을 수 있음
	- 포인터는 가리키는 대상의 주소를 저장하고 있음
	- 단순하게 대입할 경우, 두 구조체는 같은 주소를 저장하게 되며, 따라서 같은 주소를 참조하게 됨
	- 만약 한쪽 구조체의 포인터 관련 변수가 파괴될 경우, 그 여파는 대입한 다른 구조체에도 작용하게 됨: 서로간의 독립성이 보장되지 않음
- 단순 대입을 통한 복사를 얕은 복사라 하며, 포인터 멤버가 없을 경우는 이 방법으로 충분
- 포인터 멤버가 있을 경우, 별도의 메모리를 할당한 뒤 내용을 복사해야 함: 독립성을 가질 수 있음
- 이와 같은 방법을 깊은 복사라고 부름

```cpp
Kim=Albert; // 얕은 복사
Kim.pName=(char *) malloc(strlen(Albert.pName)+1);
// 문자열 변수에 대해 동적 할당작업 수행: 별도의 메모리 생성
strcpy(Kim.pName,Albert.pName);
```

## 비트 구조체
### 정의
- 비트 구조체는 비트들을 멤버로 가지는 구조체이며, 비트 필드라고도 부름
- 멤버를 설정한 뒤, 필요한 비트 수를 설정
- 원칙적으로 정수 타입만 가능하며, unsigned int와 signed int 둘 중 하나의 타입을 지정
- 통상적으로 일종의 기호, 표식을 저장하며, 따라서 unsigned int를 주로 사용
- double, 포인터 등의 타입은 비트 필드가 될 수 없음
- LSB부터 선언한 순서대로 메모리를 할당
```cpp
struct 태그명{
	타입 멤버 1: 비트수;
    타입 멤버 2: 비트수;
    ...
}
```
- 특징, 주의사항
	1. 비트 멤버의 이름을 생략할 수 있음: 코드에서 칭할 수 없으며, 자리만을 차지함
	2. 이름이 없는 비트의 크기를 0으로 설정 가능: 현재 워드의 미사용 비트를 모두 버림
	```cpp
    struct tag_bit
    {
    	unsigned short a:4; //최하위 4비트 차지
        unsigned short :0; //사용하지 않는 남은 12비트를 사용하지 않음
        unsigned short c:1;
        unsigned short d:8;
    }
    ```
    3. 비트 멤버는 자신의 타입보다 더 큰 비트 크기를 가질 수 없음
		- `int a:33;`: 에러
	4. 비트 멤버는 좌변값: 하지만 & 연산자를 사용할 수는 없음
	5. 비트 필드와 일반 멤버를 한 구조체에 같이 선언할 수 있음

## 공용체
### 정의
- 구조체와 비슷하지만, 멤버들이 기억 장소를 공유한다는 점에서 구조체와 다름
- 같은 메모리를 공유하는 멤버들의 경우, 한 멤버의 값을 변화시키면 다른 멤버의 값 역시 변화함
- 사용 이유: 원하는 타입을 읽고 쓰기 위함
	- 이경우, 공용체의 멤버들은 논리적으로 유사한 값이어야 함

### 이름없는 공용체
- 공용체 변수에 이름을 주지 않을 경우 이름없는 공용체가 됨
- 멤버는 존재하지만 변수의 이름이 생략되어 있으며, 태그는 보통 붙이지 않음
- 단순히 둘 이상의 변수가 같은 기억 장소를 공유하도록 묶어주는 역할을 수행
- 공용체 바깥의 변수와 명칭이 중복되어서는 안됨

```CPP
union { // 이름없는 공용체 선언
	int a;
    double b;
};
a=3; b=3.14 // 공용체의 변수는 일반 변수처럼 다룸
```