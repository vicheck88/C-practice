# 포인터 고급
## const
### 상수의 정의
- const는 값을 변경할 수 없는 상수를 정의
- const를 붙일 경우 반드시 초기값을 설정해주어야 함
- 정수 상수로 선언되어 있으며, 중간에 값을 변경할 수 없음: 변경 시도시 에러
- 선언 형식:
	- `const int a=10;`: 관습적으로 가장 많이 사용하는 방법
	- `int const a=10;`
	- `const a=10;`
- 매크로 상수를 정의하는 `#define`과 그 용도가 유사하며, 몇 가지 부분에서 더 나은 점을 가지고 있음
	1. 타입을 명확하게 지정할 수 있음
	2. 자신이 선언된 범위 내에서만 사용 가능(지역, 전역 변수): 명칭 간의 충돌을 최소화할 수 있음
	3. 컴파일러가 처리하므로 디버깅이 가능: 값을 확인할 수 있음
	4. `#define`과 달리 컴파일러가 문맥에 맞게 처리

### 포인터와 const
- 단일 포인터와 const

```cpp
void main(void)
{
	int ar[5] = { 1, 2, 3, 4, 5 };
	int *p1 = ar;
	p1++;
	*p1 = 0;

	const int *p2 = ar; 
    // const int를 가리키는 포인터로, 포인터 자체는 상수가 아님(상수 지시 포인터)
    // ar 자체는 상수가 아니므로 a[0]=0 식의 표현은 가능하지만 
    // 포인터 변수가 가리키는 값을 간접적으로 변경하는 것은 불가능
    
	p2++;  // 포인터가 다른 대상체를 가리킬 수 있음
	*p2 = 0;  // 대상체가 상수임으로 변경이 불가능: 에러

	int * const p3 = ar; 
    // p3 포인터 변수를 상수로 만듦: 상수 포인터
    // 변수 자체가 상수이므로 다른 대상체를 가리킬 수는 없음
    // 포인터가 가리키는 대상체는 상수가 아니므로 값을 변경할 수 있음
    
	p3++;  // 포인터가 다른 대상체를 가리킬 수 없음: 에러
	*p3 = 0;  // 대상체는 변경 가능

	const int * const p4 = ar;
    // 변수 p4와 변수가 가리키는 대상체 전부가 상수
    // p4의 증감, 혹은 가리키는 대상 변경 전부 불가능
    
	p4++;  // 포인터가 다른 대상체를 가리킬 수 없음: 에러
	*p4 = 0;  // 대상체가 상수임으로 변경이 불가능: 에러
}
```

- 이중 포인터와 const
	- 이중 포인터에는 const를 세 곳에 붙일 수 있으며, 단일 포인터와 마찬가지로 위치에 따라 의미가 다름

```cpp
void main(void)
{
	int i=5;
    int *pi1=&i;
    const int *pci; // 상수지시포인터
    int * const cpi=&i; // 상수 포인터
    const int * const cpci=&i; // 상수지시+상수 포인터

	int **ppi1=&pi1; //일반 이중포인터: 전부 가능
    ppi1++;
    (*ppi1)++;
    **ppi1=0;
    
    const int **ppi2=&pci; //상수지시포인터의 포인터
    ppi2++;
    (*ppi2)++;
    **ppi2=0; // 에러: 최종 대상체가 상수이므로 변경 불가
    
    int *const *ppi3=&cpi; //비상수 지시 상수 포인터의 포인터
     ppi3++;
    (*ppi3)++; // 에러: 중간 대상체가 상수 포인터이므로 변경 불가
    **ppi3=0;
    
    int ** const ppi4=&pi; //비상수 지시 비상수 포인터의 상수 포인터
    ppi4++; // 에러: 상수 포인터이므로 변경 불가
    (*ppi4)++;
    **ppi4=0;
    
    const int * const * const ppi5=&cpci; // 상수 지시 상수 포인터를 지시하는 상수 포인터
    ppi5++;
    (*ppi5)++;
    **ppi5=0; // 모든 항목에서 에러
}
```

- const 형식을 사용하는 이유
	- 절대로 바뀌면 안되는 중요한 값을 보호하기 위함
		- 실수로 중요한 값을 변경하게 될 수도 있음
		- 해당 값의 주소를 가진 포인터를 다루는 과정에서 예상치 못하게 값을 변경시킬 수 있음
		- const를 이용, 읽기 전용 포인터를 설정하여 값 변경이 불가능하게 만들 수 있음

### volatile
- 변수의 성질을 바꾸는 역할을 하며, const와 함께 cv지정자(Qualifier: 제한자)라고 부르기도 함
- `volatile double j` 형식으로 변수 선언
- volatile이 붙은 변수에 대해 컴파일러는 어떠한 최적화 처리도 하지 않음
- 개발자의 의도와 컴파일러의 실행이 다를 경우를 우려할 때 사용
- 프로그램 외부의 환경에 의해 결과값이 달라질 경우를 대비
- 거의 사용하지 않는 명령어

## 함수 포인터
### 정의
- 함수를 가리키는 포인터
- 함수의 시작번지를 포인터 변수로 가리킬 수 있음
- `리턴타입 (*변수명)(인수의 목록)` 형식으로 선언
	- `int func(int a);`일때
	- `int (*pf)(int);` 형식으로 함수 포인터 정의
	- `pf=func`로 함수포인터에 함수 주소 대입: func는 func 함수의 시작 주소를 가리킴
- 선언된 함수 포인터는 자신과 원형이 같은 함수의 시작 번지를 가리킬 수 있음
- 원형의 형태만 같다면 다른 함수를 가리킬 수 있음
- 함수포인터로 가리키는 함수를 간접적으로 호출할 수 있음
	- `(*pf)(2);, pf(2);`: 첫번째 방법이 문법적으로 맞는 방법이며 컴파일러는 두번째 방법도 허용 

```cpp
int func(int a)
{
	return a * 2;
}
void main(void)
{
	int i;
	int(*pf)(int a);
	pf = func;
	i = (*pf)(2); // 혹은 i= pf(2);
	printf("%d\n", i);
}
```

### 함수 포인터 타입
- 함수 포인터 타입 역시 고유한 타입이며, 따라서 원형이 다른 타입끼리는 대입, 또는 인수 전달이 불가능
	```cpp
    int (*pf1)(char *);
    void (*pf2)(double);
    pf1=pf2; // 타입이 다르므로 에러 발생: 대입 불가능
    ```
- 캐스트 연산자를 통해 강제로 대입이 가능
	```cpp
    int (*pf1)(char *);
    void (*pf2)(double);
    pf1=(int (*)(char *))pf2; // 캐스트 연산자를 통한 대입
    // 캐스트 연산자 만들기: 함수 포인터 선언식에서 변수명을 뺀 뒤 전체를 괄호로 싸줌
    ```
- 함수 포인터에 대해서도 배열, 포인터를 선언할 수 있음
	- `int (*arpf[5])(int)`: `int (*)(int)`형의 함수를 가리키는 4개의 변수 생성
	- `int (**ppf)(int)`: 함수 포인터의 포인터를 선언
- 함수 포인터를 많이 사용할 경우, typedef 명령을 통해 타입을 따로 정의한 후 사용하는 것이 더 편리
	```cpp
    typedef int (*PFTYPE)(int); 
    PFTYPE pf; //포인터 변수 선언
	PFTYPE arpf[5]; // 함수 포인터 배열 변수 선언
    PFTYPE **ppf; // 함수 포인터의 포인터 선언
    ```