# 포인터 고급
## const
### 상수의 정의
- const는 값을 변경할 수 없는 상수를 정의
- const를 붙일 경우 반드시 초기값을 설정해주어야 함
- 정수 상수로 선언되어 있으며, 중간에 값을 변경할 수 없음: 변경 시도시 에러
- 선언 형식:
	- `const int a=10;`: 관습적으로 가장 많이 사용하는 방법
	- `int const a=10;`
	- `const a=10;`
- 매크로 상수를 정의하는 `#define`과 그 용도가 유사하며, 몇 가지 부분에서 더 나은 점을 가지고 있음
	1. 타입을 명확하게 지정할 수 있음
	2. 자신이 선언된 범위 내에서만 사용 가능(지역, 전역 변수): 명칭 간의 충돌을 최소화할 수 있음
	3. 컴파일러가 처리하므로 디버깅이 가능: 값을 확인할 수 있음
	4. `#define`과 달리 컴파일러가 문맥에 맞게 처리

### 포인터와 const
- 단일 포인터와 const

```cpp
void main(void)
{
	int ar[5] = { 1, 2, 3, 4, 5 };
	int *p1 = ar;
	p1++;
	*p1 = 0;

	const int *p2 = ar; 
    // const int를 가리키는 포인터로, 포인터 자체는 상수가 아님(상수 지시 포인터)
    // ar 자체는 상수가 아니므로 a[0]=0 식의 표현은 가능하지만 
    // 포인터 변수가 가리키는 값을 간접적으로 변경하는 것은 불가능
    
	p2++;  // 포인터가 다른 대상체를 가리킬 수 있음
	*p2 = 0;  // 대상체가 상수임으로 변경이 불가능: 에러

	int * const p3 = ar; 
    // p3 포인터 변수를 상수로 만듦: 상수 포인터
    // 변수 자체가 상수이므로 다른 대상체를 가리킬 수는 없음
    // 포인터가 가리키는 대상체는 상수가 아니므로 값을 변경할 수 있음
    
	p3++;  // 포인터가 다른 대상체를 가리킬 수 없음: 에러
	*p3 = 0;  // 대상체는 변경 가능

	const int * const p4 = ar;
    // 변수 p4와 변수가 가리키는 대상체 전부가 상수
    // p4의 증감, 혹은 가리키는 대상 변경 전부 불가능
    
	p4++;  // 포인터가 다른 대상체를 가리킬 수 없음: 에러
	*p4 = 0;  // 대상체가 상수임으로 변경이 불가능: 에러
}
```

- 이중 포인터와 const
	- 이중 포인터에는 const를 세 곳에 붙일 수 있으며, 단일 포인터와 마찬가지로 위치에 따라 의미가 다름

```cpp
void main(void)
{
	int i=5;
    int *pi1=&i;
    const int *pci; // 상수지시포인터
    int * const cpi=&i; // 상수 포인터
    const int * const cpci=&i; // 상수지시+상수 포인터

	int **ppi1=&pi1; //일반 이중포인터: 전부 가능
    ppi1++;
    (*ppi1)++;
    **ppi1=0;
    
    const int **ppi2=&pci; //상수지시포인터의 포인터
    ppi2++;
    (*ppi2)++;
    **ppi2=0; // 에러: 최종 대상체가 상수이므로 변경 불가
    
    int *const *ppi3=&cpi; //비상수 지시 상수 포인터의 포인터
     ppi3++;
    (*ppi3)++; // 에러: 중간 대상체가 상수 포인터이므로 변경 불가
    **ppi3=0;
    
    int ** const ppi4=&pi; //비상수 지시 비상수 포인터의 상수 포인터
    ppi4++; // 에러: 상수 포인터이므로 변경 불가
    (*ppi4)++;
    **ppi4=0;
    
    const int * const * const ppi5=&cpci; // 상수 지시 상수 포인터를 지시하는 상수 포인터
    ppi5++;
    (*ppi5)++;
    **ppi5=0; // 모든 항목에서 에러
}
```

- const 형식을 사용하는 이유
	- 절대로 바뀌면 안되는 중요한 값을 보호하기 위함
		- 실수로 중요한 값을 변경하게 될 수도 있음
		- 해당 값의 주소를 가진 포인터를 다루는 과정에서 예상치 못하게 값을 변경시킬 수 있음
		- const를 이용, 읽기 전용 포인터를 설정하여 값 변경이 불가능하게 만들 수 있음

### volatile
- 변수의 성질을 바꾸는 역할을 하며, const와 함께 cv지정자(Qualifier: 제한자)라고 부르기도 함
- `volatile double j` 형식으로 변수 선언
- volatile이 붙은 변수에 대해 컴파일러는 어떠한 최적화 처리도 하지 않음
- 개발자의 의도와 컴파일러의 실행이 다를 경우를 우려할 때 사용
- 프로그램 외부의 환경에 의해 결과값이 달라질 경우를 대비
- 거의 사용하지 않는 명령어

## 함수 포인터
### 정의
- 함수를 가리키는 포인터
- 함수의 시작번지를 포인터 변수로 가리킬 수 있음
- `리턴타입 (*변수명)(인수의 목록)` 형식으로 선언
	- `int func(int a);`일때
	- `int (*pf)(int);` 형식으로 함수 포인터 정의
	- `pf=func`로 함수포인터에 함수 주소 대입: func는 func 함수의 시작 주소를 가리킴
- 선언된 함수 포인터는 자신과 원형이 같은 함수의 시작 번지를 가리킬 수 있음
- 원형의 형태만 같다면 다른 함수를 가리킬 수 있음
- `++,--` 등의 연산자를 사용할 수 없으며, 정수와 가감 연산 역시 불가능: 함수는 코드 덩어리이며, 수시로 코드의 크기가 바뀜
- 함수포인터로 가리키는 함수를 간접적으로 호출할 수 있음
	- `(*pf)(2);, pf(2);`: 첫번째 방법이 문법적으로 맞는 방법이며 컴파일러는 두번째 방법도 허용 

```cpp
int func(int a)
{
	return a * 2;
}
void main(void)
{
	int i;
	int(*pf)(int a);
	pf = func;
	i = (*pf)(2); // 혹은 i= pf(2);
	printf("%d\n", i);
}
```

### 함수 포인터 타입
- 함수 포인터 타입 역시 고유한 타입이며, 따라서 원형이 다른 타입끼리는 대입, 또는 인수 전달이 불가능
	```cpp
    int (*pf1)(char *);
    void (*pf2)(double);
    pf1=pf2; // 타입이 다르므로 에러 발생: 대입 불가능
    ```
- 캐스트 연산자를 통해 강제로 대입이 가능
	```cpp
    int (*pf1)(char *);
    void (*pf2)(double);
    pf1=(int (*)(char *))pf2; // 캐스트 연산자를 통한 대입
    // 캐스트 연산자 만들기: 함수 포인터 선언식에서 변수명을 뺀 뒤 전체를 괄호로 싸줌
    ```
- 함수 포인터에 대해서도 배열, 포인터를 선언할 수 있음
	- `int (*arpf[5])(int)`: `int (*)(int)`형의 함수를 가리키는 4개의 변수 생성
	- `int (**ppf)(int)`: 함수 포인터의 포인터를 선언
- 함수 포인터를 많이 사용할 경우, typedef 명령을 통해 타입을 따로 정의한 후 사용하는 것이 더 편리
	```cpp
    typedef int (*PFTYPE)(int);
    PFTYPE pf; //포인터 변수 선언
	PFTYPE arpf[5]; // 함수 포인터 배열 변수 선언
    PFTYPE **ppf; // 함수 포인터의 포인터 선언
    ```

### 포인터로 함수 호출하기
- 함수 포인터는 변수이기 때문에 언제든지 다른 함수를 가리킬 수 있음
- 함수 포인터를 통해 함수를 다른 함수에게 인수로 전달할 수도, 함수 포인터 배열, 구조체를 통해 여러 개의 함수군을 동시에 다룰 수 있음

```cpp
int multi2(int a) {...}
int multi3(int a) {...}
void main
{
	int (*pf)(int a); //함수 포인터 설정
    pf=multi2;
    printf("%d",multi2(a));
    pf=multi3;
    printf("%d",multi3(a)); // 경우에 따라 함수를 바꿀 수 있음
}
```

- 함수 포인터를 사용하는 것이 좋은 경우
	1. 선택해야할 함수가 두 개 이상일 경우: 수십개의 함수 중 하나를 호출해야할 경우, 함수 포인터 배열을 선언하고 그 첨자를 선택하는 것이 쉬움
	2. 함수를 선택하는 시점과 실제로 호출하는 시점이 분리되어 있는 경우
	3. 호출할 함수가 DLL 같은 외부 모듈에 있고 이 함수를 동적으로 연결할 경우: 컴파일 때 함수의 존재가 알려지지 않으므로 함수 포인터를 이용, 이름으로부터 원하는 함수의 번지를 찾아 호출할 수 있음

### 함수 포인터 인수
- 함수 포인터는 변수임으로, 함수의 인수로 전달될 수 있음

```cpp
void qsort(void *base, size_t num, size_t width,
            int (*compare)(const void *, const void *))
//퀵소트 함수 qsort의 원형: 함수 포인터를 인수로 받음
//인수로 사용하는 함수는 값의 대소를 비교하는 함수
```

### 함수 포인터 리턴
- 함수 포인터를 리턴값으로 지정하는 것 역시 가능: 많이 쓰이지는 않음
	- `fp의 리턴타입 ((*함수명)(인수목록))(fp의 인수목록)`

```cpp
int (*func(char ch))(int, double) {}
// 함수의 이름은 func로 char 타입을 인수로 취함
// 리턴하는 함수 포인터: int,double을 인수로 가지고 int를 리턴하는 함수
```

## 가변 인수
### 가변 인수 함수
- 가변 인수: 인수의 개수, 타입이 미리 정해져 있지 않다는 뜻으로, 가변 인수를 사용하는 함수를 가변 인수 함수라고 부름
- 대표적으로 `printf` 함수가 있음
	- `int printf(const char *format,...)`: 원형
	- 생략기호 `...`: 컴파일러에게 이후의 인수에 대해서는 개수, 타입을 점검하지 않도록 하며, 이를 통해 가변 인수가 가능해짐
	- 컴파일러는 `...` 이후의 내용은 점검하지 않고 바로 함수에게 넘김: 인수의 타입 판별은 함수가 알아서 해야 함
	- `...` 이전의 인수는 고정인수이며, 반드시 포함해야 하는 인수
- 가변 인수 함수의 구조:

```cpp
void VarFunc(int Fix,...)
{
	va_list ap;
    va_start(ap,Fix);
    while(모든 인수를 다 읽을 때까지)
    {
    	va_arg(ap,인수타입)
	}
    va_end(ap);
}
```
1. `va_list ap`
	- 스택에 저장되어 있는 인수를 꺼내기 위해 사용
	- 가변인수가 위치한 번지를 읽어들이는 포인터 변수로 여길 수 있음
	- 타입은 `char *`
2. `va_start(ap,마지막고정인수)`
	- ap 포인터 변수가 첫 번째 가변 인수를 가리키도록 초기화
	- 이를 위해 마지막 고정 인수를 전달
3. `va_arg(ap,인수타입)`
	- 가변 인수를 실제로 읽는 명령
	- ap_start가 가변 인수 번지를 찾아주므로, ap위치의 값을 읽기만 하면 됨
	- 두번째 인수를 통해 읽고자 하는 값의 타입을 지정 
		- `va_arg(ap,int)`: ap 위치에 있는 정수값을 읽고자 할 때 사용
	- 이 함수는 매크로 함수: 내부적으로 sizeof, 캐스트 연산자로 전달되며 따라서 다른 함수와 달리 타입을 인수로 지정할 수 있음
4. `va_end(ap)`
	- 가변 인수를 읽은 뒤의 뒷정리
	- 인텔 cpu계열에서는 사용할 필요가 없으나, 다른 환경에서는 필요할 수 있음

```cpp
#include <stdio.h>
#include <stdarg.h> // va_ 매크로 함수들을 저장하고 있음
int getsum(int num, ...) //가변적으로 주어진 수들의 합을 구하는 함수
// num: 고정인수로, 더하는 수의 개수
{
	int sum = 0;
	int i;
	va_list ap;
	va_start(ap, num);
	int arg;

	va_start(ap, num);
	for (i = 0; i < num; i++)
	{
		arg = va_arg(ap, int);
		sum += arg;
	}
	va_end(ap);
	return sum;
}
void main(void)
{
	printf("1+2=%d\n", getsum(2, 1, 2));
	printf("3+4+5+6=%d\n", getsum(4, 3,4,5,6));
	printf("10~15=%d\n", getsum(6, 10,11,12,13,14,15));
}
```

### 가변 인수 함수의 조건
1. 반드시 하나 이상의 고정 인수를 가져야 한다: 가변 인수를 읽기 위한 포인터 ap를 초기화하기 위해서는 마지막 고정 인수의 번지를 알고 있어야 하며, 따라서 고정인수가 없을 경우 작동하지 않음
만약 고정 인수를 가지지 않는 가변 인수를 만드고 싶다면, va_ 매크로 대신 스택에 직접 접근해야 하며, 일반적으로 불가능
2. 함수 내부에서 가변 인수의 개수를 알 수 있도록 해야 함: 앞부분의 고정인수를 통해 가변 인수의 개수 전달, 혹은 가변 인수의 목록 끝에 특이값을 전달하여 개수를 간접적으로 알려줄 수 있음
3. 함수 내부에서 가변 인수 타입을 알 수 있어야 함: 모든 인수를 특수한 타입으로 고정하거나, 가변 인수의 타입이 약속되어 있어야 함
`va_arg` 매크로가 ap번지에서 가변 인수를 읽을 때 해석해야 하는 타입을 알고 있어야 하기 때문
`printf`는 서식의 형태를 통해 가변 인수의 타입을 알 수 있음

```cpp
void main(void)
{
	printf("%d%d\n", 1, 2); //옳은 표기법
	printf("%d%d\n", 1, 2,3,4); //뒤의 3,4는 무시됨
	printf("%d%d\n", 1, 2.5); //정수형 타입으로 알고 있어, 2.5를 정수형으로 읽음(0)
	printf("%f%f\n", 1, 2); //정수형을 실수형으로 읽음
	printf("%s\n", 1);//정수형을 문자열로 읽음: 1을 주소로 인식, 주소 1의 값을 출력하고자 함: 에러
}
```

### 가변 인수 함수의 활용
- 가변 인수 함수는 한 번의 호출로 여러 개의 정보를 다양한 방법으로 다룰 수 있어 편리
- `vprintf, vsprintf` 로 `printf`같은 함수를 구현할 수 있음
	```cpp
    int vprintf(const char *format, va_list argptr);
    int vsprintf(char *buffer, const char *format, va_list argptr);
    ```
	- 이 외에도 `vscanf, vsscanf` 등의 함수도 존재
	- 가변 인수가 시작되는 번지를 인수로 취하며 실제로 가변 인수를 취하지는 않음

```cpp
void CustomTrace(char *format,...) //실행 중 변수값을 디버거로 실시간 확인
{
	char buf[1024];
	va_list marker;

	va_start(marker, format); // 첫번째 가변인수의 번지
	vsprintf(buf, format, marker); //구한 가변인수의 번지를 vsprintf로 넘김
	OutputDebugString(buf); //주어진 문자열을 디버깅 창으로 출력
}
CustomTrace("변수 a=%d, 변수 f=%f\n",a,f); // 사용 예
CustomTrace("함수 func가 %d번째 호출되었음",count++);
```
