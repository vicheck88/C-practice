# 연산자
## 산술 연산자
#### 연산자의 종류
- 프로그램은 데이터와 코드로 구성됨.
	- 데이터: 프로그램이 처리하는 재료.
	- 코드: 데이터를 가공하는 수단.
	- 데이터(자료)를 가공하여 정보를 만드는 주된 수단.

#### 산술 연산자
- 산술 연산자는 가장 기본적인 연산자로 `+,*,/,%`로 구성되어있음.
- % 연산자는 나누어 떨어지는 나머지를 출력.
- 다른 연산자는 상식과 일치하나 '/' 연산자에 대해선 어느정도의 주의가 필요.
	- `6/3=2` `3.0/2.0=1.5` `3/2=1` (정수형에서의 나눗셈은 몫만 취하고 나머지는 버림.)
- 부호 연산자: 피연산자의 부호를 변경.

#### 대입 연산자
- 대입: 변수에 어떤 값을 집어넣는 동작.
- 대입 연산자: 변수의 값을 변경할 때 사용.
- `=` 기호를 사용.
- 대입 연산자의 우변에는 상수, 변수, 연산자들로 구성된, 계산할 수 있는 표현식이 오며 함수 호출문도 올 수 있음. 좌변에는 좌변값(lvalue: left value)만 올 수 있음.

###### 좌변값
- 좌변값: 실제적인 메모리를 점유하고 있고 그 값을 바꿀 수 있는 대상
- `i=1`: i는 실제 메모리를 점유하고 있고 값을 마음대로 바꿀 수 있으므로 좌변값.
- `1=2+3` 1은 상수항으로 메모리를 실제로 점유하고 있지 않고 값을 바꿀 수 없으므로 좌변값이 아님.
- `a+b=4` 각각의 변수는 좌변값이지만, 두 변수의 수식은 좌변값이 아님.
- 배열 요소는 좌변값이지만 배열 자체는 좌변값이 아님.
	
###### 리턴값
- 리턴 값은 연산 후 연산자가 연산 결과를 돌려주는 값.
- `a=b=c=5` 대입 연산자가 값을 리턴하므로, 우에서 좌로 차례차례 연산이 수행됨.

###### 복합 대입 연산자
- 대입 연산자와 다른 연산자가 결합된 연산자.
- = 연산자에 다른 연산자가 대입된 형태.
	- `a+=3` 대입 연산자로, `a=a+3`과 같은 의미를 가짐.
- 대입 연산자의 종류
	- `+=,-=, /=, *=, %=, <<=, >>=, &=, |=, ^=`

#### 증감 연산자
- 피연산자를 1씩 증가시키거나 감소시킴.
- 증가 연산자는 `++`, 감소 연산자는 `--`로 쓰임.
- 증감시킬 값이 1로 고정되어 있고 피연산자가 하나: 단항 연산자.
- 연산자의 위치에 따라 전위형(prefix), 후위형(postfix)로 나뉨.
- 전위형은 값을 먼저 증감시킨 후 전체 값을 리턴.
- 후위형은 먼저 전체 값을 리턴한 뒤 증감시킴.
- 증감 연산자는 대입 연산자와 비슷하며, 역시 좌변값을 필요로 함

```cpp
i=3
printf("%d",i++); //i값을 먼저 출력한 뒤 i 증감: 3으로 출력, i=4;
printf("%d",++i); //i값을 먼저 증감한 뒤 i 값 출력 : 4로 출력, i=4;

++i++; // 증감연산자를 수행하는 상황에서 좌변값이 상수항으로 변화하여 오류 생성
i++++;
++++i;
```
#### 복잡한 수식
- 복잡한 수식에서 증감 연산자를 사용할 때 문제가 생길 수 있음.
```cpp
void main()
{
	int i = 3;
	printf("%d, %d\n", i, ++i);  // 출력결과: 4 , 4
}
```
- C 언어가 인수를 전달하는 방향은 지정되어 있지 않으며 대부분의 컴파일러는 뒤의 인수부터 평가함: 가변 인수를 다루기 편하기 때문.
- 따라서 증감 연산자를 수식 내에서 다루는 것은 바람직하지 않음.

## 논리 연산자
#### 관계 연산자
- 관계 연산자: 피연산자를 두 개 취하는 이항 연산자로 좌변과 우변의 값을 비교.
	- `==, !=, >, <, >=, <=`
	- `==, !=`는 따로 상등 연산자라고 불림.
- 주로 if문과 함께 사용되며 for, while에서도 사용됨.
- 수식이 참일 경우 1(true), 거짓일 경우 0(false) 리턴.

#### 논리 연산자
- 두 개 이상의 조건식을 결합, 하나의 진리값을 만들어 냄
- `!(not), &&(and), ||(or)`의 세 가지 경우가 있음

###### Short Circuit
- 논리 연산에서 뒤의 수식과 상관없이 판정 결과가 이미 나올 경우의 논리.
	- 뒤의 수식 결과에 상관없이 동작이 수행되어, 뒷 연산은 수행되지 않음.
	- 이를 Short circuit이라 하며, 프로그램의 속도를 높이기 위해 사용됨.

```cpp
void main()
{
	int a = 4, b = 0;
	if (a == 5 && b = 3) b++; 
    //연산자 우선순위에 의해 ((a==5) && b)=3. 좌변은 0이므로 l-value 오류 발생
	printf("%d\n", b);
    
	if ((a == 5) && (b = 3)) b++; 
    // a==5 구문이 0이므로 b=3 연산 수행 안함. 따라서 b=0
	printf("%d\n", b);
    
	if ((a < 5) || (b = 3)) b++; 
    // a<5 구문이 참이므로 예제 20처럼 b=3 연산 수행 안함. 따라서 b++가 적용되어 b=1
	printf("%d\n", b);
}
```

#### 비트 연산자
- 비트 연산자는 비트를 연산 대상으로 한다는 점에서 논리 연산자와 다름.
- 두 피연산자의 대응되는 비트끼리 연산, 그 결과를 리턴.

```cpp
~ : 비트 반전 (단항 연산자) (NOT).
& : 대응되는 비트가 모두 1일 때 1 (AND).
| : 대응되는 비트가 모두 0일 때 0 (OR).
^ : 두 개의 비트가 달라야 1 (XOR).
<<: 지정한 수만큼 왼쪽으로 비트들을 이동.
>>: 지정한 수만큼 오른쪽으로 비트들을 이동.
```
- 연산자 설명
	- ~: 반전 연산자. 이미지 처리에 많이 사용됨(픽셀값을 뒤집어 역상 이미지를 얻음.)
	- &, |: 특정 비트를 0 또는 1로 만들 때 사용됨. 일부 비트만 제한적으로 읽거나 쓸 때 사용.
	- ^ : 지정한 비트만을 반전시키는 연산.]

###### 쉬프트 연산자
- 비트들을 지정한 수만큼 좌우로 이동시킴.
- <<: 왼쪽으로 비트를 이동, >>: 오른쪽으로 비트를 이동.
- 피연산자는 주로 부호없는 정수형이며, 실수형은 불가.
- 부호 있는 정수형의 경우 계산은 가능하지만 큰 의미를 가지지 않는다.

![비트연산.png](.\image\비트연산.png)

#### 쉬프트 연산의 곱셈, 나눗셈
- 쉬프트 연산은 곱셈, 나눗셈으로 사용 가능하며, 일반적인 곱하기 연산보다 훨씬 빠른 속도를 기대할 수 있음.
	- `<<` 연산을 이용할 경우, 원래 수보다 2배 증가.
	```cpp
    a=1101=2^3+2^2+2^0
    a<<1=11010=2^4+2^3+2^2=2*a // 쉬프트 연산에 의해 2배로 증가.
    ```
- `>>` 연산으로 나눗셈 역시 가능. But 오차가 존재.
- 쉬프트 연산으로는 2의 거듭제곱승에 대해서만 계산이 가능하며, 그 외의 곱은 다른 방법을 고안해야 함.

```cpp
3배: a<<1+a;			15배: a<<4-a;
9배: a<<3+a;			60배: a<<6-a<<2;
```
#### 회전 연산
- 회전 연산: 쉬프트 연산과 비슷한 비트 조작 명령.
- 비트를 원형으로 이동시키며, 밀려나는 비트는 버려지지 않고 반대쪽으로 이동.
- 연산자 형태로 따로 제공되지 않으며, 과거 도트, 잉크젯 프린터의 헤더 배열에 사용.
- 원래 값으로의 복구가 가능: 암호화에 적당.

## 기타 연산자
#### 삼항 조건 연산자
- 유일하게 세 개의 피연산자를 가지고 있음.
- 결국 if와 같음: `(조건식) ? 값1 : 값2`
- 여러줄로 써야할 코드를 한 줄로 표현할 수 있다는 것이 장점.
- 값들은 형식에 제한이 없지만 동일한 타입을 가져야 함.
- 호출 연산자를 사용하므로 함수호출 역시 가능
- 피연산자로 식은 가능하지만 문장은 불가능

```cpp
c=if(b<5) a;else b; //다음과 같은 식은 불가능
c=(b<5)? a:b; // 다음과 같이 삼항연산자를 사용할 때는 오류가 없음
int a=10;
a ? printf("True\n", a++) : printf("False\n", a--); // 이는 가능
a ? {printf("True\n"); a++;} : {printf("False\n"); a--;} // 이는 불가능

```

- 조건 연산자는 삼항 연산자로, 우선순위가 낮은 편(대입과 ,보다는 높다)

#### 쉼표 연산자
- 여러 수식을 ,(쉼표)로 묶을 수 있음
- 조건식에 사용할 경우, 복합식으로 사용 가능
- 마지막 수식의 결과를 바탕으로 연산 수행
- 단순 구분으로서의 ,와 연산자로서의 ,를 구분할 수 있어야 함
- 연산자 중 가장 낮은 우선 순위를 가지고 있으며, 때문에 괄호를 통해 구분해야 함.
	- ex) `a,b: 단순 구분, (a,b): ,연산의 결과`


```cpp
void main()
{
	int a, b, c;
	if (a = 3, b = 4, c = 0) printf("True\n"); //마지막 c=0을 반영: 결과는 false
	else printf("False\n");
	printf("%d, %d, %d",a,b,c);
}  
```
```cpp
int add(int a, int b) // add 함수 생성
{
	return a + b;
}
void main(void)
{
	int a;

	printf("%d\n", add(3, 4, 5)); // parameter가 2개여서 처음 두 argument(3,4)만을 받아들임
	printf("%d\n", add(3, (4, 5))); // parameter는 3과 (4,5). ,연산에 의해 마지막 5 반영

	a = 3, 4;
	printf("%d\n", add(a, 10)); //parameter: 처음 결과인 3이 반영
	a = (50, 100);
	printf("%d\n", add(a, 200)); // a=(50,100)으로 마지막 결과인 100이 대입
}
```
```cpp
void main()
{
	int a, b, c;
	a = (b = 3, c = b + 4, c + 1); // b=3, c=b+4=7. 마지막 연산으로 a=c+1=8
	printf("%d, %d, %d\n", a, b, c); // 결과: 8, 3, 7

	a = b = 3, c = b + 4, c + 1; // a=b=3, c=b+4=7이 됨
	printf("%d, %d, %d\n", a, b, c); // 결과: 3, 3, 7
}
```

#### sizeof 연산자
- 피연산자로 주어진 타입 또는 변수의 크기(사용하고 있는 메모리의 크기)를 계산.
	- `sizeof(타입 또는 변수)`
- sizeof는 컴파일러가 계산하며 결과는 정수 상수.
- 실용적인 사용 예: 배열의 크기를 계산할 때
	- `int a[100]의 크기= 4*100=400Byte`

#### 캐스트 연산자
- 수식 내에서 변수의 타입을 강제로 다른 타입으로 변환.
	- `(타입) 변수`