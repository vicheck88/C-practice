# 함수
## 함수의 구성원리
#### 정의
- 함수는 프로그램을 구성하는 단위로 프로그램의 부품 역할을 함.
- 일반 함수들은 부품, main 함수는 cpu에 비유할 수 있음.
- 함수에는 표준 함수, 사용자 정의 함수가 있음
	- 표준 함수: 컴파일러와 함께 배포되는 함수 (`printf, scanf` 등)
	- 사용자 정의 함수: 개발자가 필요에 따라 만들어 쓰는 함수

#### 형식
- 형식은 다음과 같음: `type name(인수 목록) {함수 본체}`
	- name: 함수의 이름으로 이를 통해 함수 호출.
	- 인수 목록: 함수의 동작에 필요한 인수로 개수의 제한은 없음.
	- type: 함수가 리턴하는 값의 데이터형. 리턴하는 값이 없을 경우는 void 함수라 함.
	- 본체: 실제 함수의 코드로, {} 안에 위치.

#### 인수
- 인수: 호출원에서 함수에게 넘겨주는 작업 대상.
- 두 함수 사이의 정보교환에 사용되므로 매개 변수(Argument)라고도 함.
- 형식인수와 실인수로 구분
	- 형식인수(Parameter): 인수 목록에 나타나는 인수.
	- 실인수(Argument): 함수 호출부에서 함수와 함께 전달되는 인수.
	- 형식 인수는 호출원에서 전달한 실인수값을 잠시 저장하기 위함 임시 저장 장소로, 어떤 값을 사용하든 상관없음.
	- 함수가 받을 수 있는 인수의 개수에는 제한이 없으며, 인수 목록에 콤마(,)로 구분하여 나열.

#### return
- 함수가 호출원으로 돌려주는 작업 결과.
- return문을 사용하여 결과를 리턴.
- 함수가 리턴하는 결과값의 타입은 이미 정의되어 있음.
- 함수는 단 하나의 결과값을 리턴할 수 있으며, 때문에 함수 중간에 return이 있을 때 함수를 강제 종료.

#### C 함수의 특징
- 서로 평등한 관계에 있으며 상호 수평적이어서 함수끼리 언제나 호출이 가능하며 한 함수가 다른 함수에 예속되지 않음.
- main함수는 함수 중 가장 기본이 되지만, 다른 함수들과 크게 다른 점은 없음.
- 리턴값은 있을수도, 없을수도 있음.
- 항상 단독으로 문장을 구성할 수 있음.
- 값에 의한 호출 방식을 사용함: 실인수가 형식인수에 대입될 때 항상 값이 대입됨.

## 헤더 파일
#### 함수의 원형
- C언어는 컴파일 방식을 사용: 소스를 읽어 기계어로 한꺼번에 번역.
- 일반적으로 C 컴파일러는 한번에 소스를 다 읽고 번역: 1 패스 방식.
- 이러한 컴파일러를 위해 원형(ProtoType)이라는 개념이 등장
	- 원형: 함수에 대한 정확한 정보라는 뜻으로, 함수의 리턴 타입, 함수 이름, 인수 리스트 등의 정보로 구성됨
	- 컴파일러는 일반적으로 순서대로 함수를 읽어들이기 때문에 함수의 호출 순서가 다를 경우 에러를 일으키는 일이 생김.
	- 이를 해결하기 위해 소스의 처음 부분에 원형을 설정, 컴파일러에게 숙지시키도록 함.

#### 원형의 형식
- 함수의 본체는 적지 않으며, 리턴 타입, 함수 이름, 인수 목록만을 작성.
	- `int Max(int a, int b);`
	- 형식 인수의 이름은 상관 없으며, 이름을 적지 않아도 됨.
- 정확한 의미 전달을 위해 원형은 완전한 형태로 구성하는 것이 좋음.

#### 헤더 파일
- 표준 함수의 원형은 stdio.h 파일에 들어있음: 컴파일러 제작사가 미리 원형을 제작하여 배포.
- 이처럼 표준 함수의 원형을 미리 작성해 놓은 것을 헤더 파일이라 부름
- 헤더파일에 들어있는 정보:
	- 표준 함수의 원형
	- 표준 함수들이 사용하는 매크로 상수들
	- 표준 함수들이 사용하는 열거형 타입
	- 자료의 가공을 간편하게 해 주 는 매크로 함수들
	- 구조체, 공용체 등 표준 함수가 요구하는 사용자 정의 타입
- 헤더 파일의 종류
|헤더 파일|함수|예|
|---
|stdio.h|표준 입출력에 관한 함수|printf,scanf,puts|
|conio.h|키보드 및 화면 입출력 함수|atoi,itoa,malloc,free|
|math.h|수학 함수들|sin,cos,log|
|string.h|문자열 조작 함수들|strcpy,strlen|

#### 모듈
- 하나의 실행 파일을 만들기 위한 소스를 여러 개로 나누어 개발하는 방식
- 원형만 선언한다면 함수의 본체가 어디에 있든 상관 없기 때문에 가능한 개념.
- 사운드, 그래픽 등 각 분야 별로 모듈을 만든 뒤, 이들을 후에 하나의 실행 파일로 만듬.
- 이점:
	- 컴파일 속도가 빠름.
	- 분담 작업기 가능.
	- 프로젝트 관리가 쉬움.
	- 모듈의 재사용이 가능.

## 함수 호출 방식
#### 값 호출
- 인수의 전달 방법에 따라 값 호출(call by value) 방식과 참조 호출(call by reference) 방식이 있음.
- 값 호출: 실인수의 값이 형식 인수로 전달되는 방식.
	- 함수의 형식인수에 main의 실인수를 대입하는 방식.
	- 실인수 자체가 아닌 실인수가 가지고 있는 값을 대입.
	- 단순히 값만 호출된 상태이며, 이들은 서로 다른 메모리 주소를 가지고 있음.
	- 실 인수의 값에는 변화가 없음.
	- 상수를 실인수로 사용하는 것이 가능.

#### 참조 호출
- 실인수의 값이 아닌 주소를 전달하는 방식
- 실인수의 주소 안 값을 변화시켰으므로, 실 인수의 값이 변경됨.
- 주소를 가지고 있어야 하므로, 상수를 실인수로 사용할 수 없음.

## 전처리기
- 전처리기는 "앞서 먼저 처리하는 명령"이라는 뜻을 가지고 있으며, 컴파일 이전에 소스를 재작성하는 역할을 함.
- 코드를 생성하지 않으며 소스를 재구성 함.
- 반드시 한 행을 모두 차지해야 하며 전처리문 뒤에 C 코드를 같이 쓸 수 없다.

#### `#include`
- 괄호안의 파일을 읽어 현재 위치에 삽입.
- `#include <stdio.h>`는 현재 소스에 stdio.h 파일의 내용을 삽입: 메모리에서 소스를 재작성.
- 헤더파일만 가능한 것은 아니며, cpp,txt 등의 파일 형식도 가능.
- 중첩하여 쓰는 것이 가능하며 포함한 파일이 다른 파일을 포함하고 있을 경우 포함된 모든 파일을 불러들임.
- 사용하는 괄호에 따라 두 가지 방법이 있음:
	- `#include <file.h>`: C에서 제공하는 표준 헤더파일을 포함시킬 때 사용.
	- `#inlcude "file.h"`: 사용자가 직접 작성한 헤더 파일을 포함시킬 때 사용. 소스 파일과 같은 디렉토리에서 헤더 파일을 검색하며, 절대 경로를 지정하여도 됨.

#### `#define`
- 매크로 함수를 정의하며, `#define 매크로명 실제값`의 형식을 가짐.
- 자주 사용하는 숫자, 개념들을 미리 정의하여 사용하기 쉽도록 만듬
	- `#define MACH 1200.0`: 마하와 km를 변환하는 식을 처음에 정의.
- 주의사항
	- `#define`문은 전처리문이지 코드를 생성하는 명령이 아님: 행 끝에 세미콜론은 붙이지 않음.
	- 매크로 역시 일종의 명칭이므로 명칭 규칙에 맞게 작성해야 함.
	- 매크로 이름에는 공백이 들어갈 수 없지만, 매크로 실제값에는 들어갈 수 있음
		- `#define ERRMESSAGE "제대로 해"`: 정상적으로 작동.
	- 문자열 상수 내에 있는 매크로나 다른 명칭의 일부로 포함된 경우는 치환되지 않음.
	- 중첩 가능
		 ```cpp
		#define A 3
        #define B (A*2) // B가 A를 참조하며 결과는 A=3, B=6.
		 ```
	- 값이 없는 빈 매크로 역시 정의 가능
		- `#define PROFESSIONAL`: 값을 가지지 않으며 매크로 상수 자체만 존재.

#### 매크로 함수
- `#define` 전처리기를 사용하여 함수 흉내를 내는 것.
- 인수를 받아들이며, 인수 전달을 위해 매크로 이름 다음에 괄호가 사용됨.
	- `#define dubae(i) i+i`
- 주의점
	- 매크로 함수의 전체식을 괄호로 싸야 함: 다른 연산자들과의 우선순위에서 밀릴 수 있음.
	- 매크로의 인수들도 개별적으로 괄호로 싸줌: 인수가 복잡한 수식일 경우 수식에게 우선권을 주기 위함.
	```cpp
    #deinfe jegop(i) (i*i)
    // i=3+1을 대입할 경우, 결과값은 (3+1*3+1)이 되어버림. 따라서
    #define jegop(i) ((i)*(i))로 정의해야함.
    ```
    - 매크로 함수는 인수의 타입을 점검하지 않으며, 인수에 어떤 것을 넣든 그대로 동작함.
    - 여러 개의 명령을 동시에 포함시킬 수 있음: 자주 사용하는 명령의 집합들을 매크로로 묶어놓을 수 있음.
    - ++,--와 같은 증감 연산자, 또는 +=,*= 등의 연산자는 쓰지 않는 것이 좋음: 표준 규정이 없어 컴파일러마다 결과가 제각각이며 틀린 결과가 나오는 경우도 많음.