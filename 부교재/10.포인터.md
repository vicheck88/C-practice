# 포인터
## 포인터 연산
### 포인터의 타입
- 포인터는 메모리의 번지값을 가지는 변수.: 포인터 안의 값은 4B의 unsigned int.
- 포인터가 가리키는 번지에 들어있는 값, 즉 포인터가 가리키는 대상을 대상체(object)라고 부름.
- 포인터 변수를 선언할 때, 가리키고자 하는 대상체의 타입을 반드시 명시해야함(포인터의 타입)
	- `int *pi`: 정수에 대한 포인터형, 즉 정수형 변수를 가리키는 포인터형
- 포인터가 타입을 가져야 하는 이유
	1. `*` 연산자로 포인터의 대상체를 읽거나 쓸 때, 대상체의 바이트 수와 비트 해석 방법을 알기 위해
		- 연산자가 제대로 값을 읽기 위해서는 대상체의 타입을 정확히 알고 있어야 함
		- `double` 타입의 값을 `int`로 읽을 경우 많은 문제가 생김.
		
	2. 인접한 다른 대상체로 이동할 때 이동 거리를 알기 위해
		- 포인터 변수에 대해 증감 작업을 수행할 때, 변수는 다음, 혹은 이전 변수값으로 이동해야 함.
		- 포인터가 가리키는 타입에 따라 다음, 혹은 이전 번지값으로의 이동 정도가 달라지므로, 이를 감안할 경우 포인터의 타입이 반드시 필요함.: 포인터 변수 p에 정수 i를 더할 경우, `p=p+(i*sizeof(type))`이 됨.

### 포인터 연산
- 포인터 연산: 피연산자 중의 하나가 포인터인 연산
1. 포인터끼리 더할 수 없다: 번지값끼리 더하거나 빼는 것에는 아무런 의미가 없음.
2. 포인터끼리 뺄 수는 있음: 뺄셈은 두 요소간의 상대적인 거리를 의미하며 이 값은 정수타입.
3. 포인터에 정수를 더하거나 뺄 수 있다: 포인터 요소를 중심으로 떨어진 번지를 찾아낼 수 있음.
4. 포인터끼리 대입할 수 있음
5. 포인터와 실수와의 연산은 불가능
6. 포인터에 곱셈, 나눗셈은 불가능
7. 포인터 간의 비교는 가능: 자주 이용되지는 않으나, 포인터값의 유효성 검증을 위해 NULL값과 비교하는 연산은 자주 이용됨.

### `*p++`
- `*p`와 `++`의 조합에 따라 다양한 결과가 나타남
1. `*p++==*(p++)`: 포인터의 값을 구한 뒤 번지수를 한 칸 이동
2. `*++p`: 먼저 번지수를 한 칸 이동한 뒤 그 번지에서의 값을 구함
3. `(*p)++`: p가 가리키는 값을 증가시킴. 번지 이동 없음.

## void형 포인터
### void형
- void형 포인터는 선언할 때 대상체의 타입을 명시하지 않음
	- `void *p`의 꼴을 가짐.
	- void형은 함수와 포인터 변수에게만 적용되며, 일반 변수에는 사용 불가.
- void형의 특징
	1. 임의의 대상체를 가리킬 수 있다: 정수, 실수 등의 여부에 상관없이 모든 대상체를 대입할 수 있음.
		- 임의의 포인터에 void형 포인터를 대입할 경우, 캐스팅 연산이 반드시 필요함: `pi=)int *) vp;`
	2. `*` 연산자를 사용할 수 없음.: 임의의 대상체에 대한 번지값만을 저장하며, 이 번지에 어떤 값이 들어있는지를 모르기 때문에 번지 안의 값을 읽을 수 없음.
	3. 증감 연산자를 사용할 수 없음: 대상체의 타입을 모르므로 증감 연산자 역시 바로 사용할 수 없음. 증감 연산자를 사용하기 위해서는 캐스팅 연산을 통해 잠시 포인터에 타입을 부여해야함.

- 활용: 모든 상황에서 대상체가 미리 결정되어 있을 수는 없으며, void형 포인터는 이경우 임의의 대상체에 대해 동작하기 위해 사용됨.

### NULL 포인터
- 0으로 정의되어 있는 포인터 상수.
- 0번지는 메모리 공간의 제일 처음에 해당되며, 일반적으로 ROM 등의 영역에 해당되어 보호됨.
- 대부분의 함수는 에러가 발생할 때 NULL 값을 리턴하며, 따라서 이에 대한 적절한 처리가 필요함.
- 일반적으로 포인터에 상수 번지를 대입하는 것은 금지되어있으나, NULL과의 비교, 직접적인 연산은 허용됨.

## 동적 메모리 할당
### 할당의 필요성
- 동적 할당은 실행 중에(Run time) 필요한 만큼 메모리를 할당하는 기법.
- 메모리의 필요량을 전혀 예측하지 못하는 경우, 또는 지나치게 메모리를 낭비하는 경우, 그리고 임시적인 메모리가 필요할 경우 사용.

### 메모리 관리 원칙
- 메모리는 보통 운영체제가 관리하며, 원칙은 다음과 같음
1. 응용 프로그램은 메모리를 직접 관리할 수 없으며, 운영체제에 할당 요청을 해야 함.
2. 운영체제는 메모리가 남아있는 한 요청을 거절하지 않음.
3. 한 번 할당된 메모리 공간은 반납할 때까지 절대 다른 목적을 위해 재할당되지 않음.
4. 응용 프로그램이 메모리를 해제할 경우, 운영체제는 이 공간을 빈 영역으로 인식, 다른 목적을 위해 사용할 수 있도록 함.

### 할당 및 해제
- 할당에는 다음과 같은 함수를 사용
	```cpp
    void *malloc(size_t size);
    void free(void *memblock);
    ```
- `malloc`: 인수로 필요한 메모리양을 바이트 단위로 전달, 요청한 만큼 할당.
	- malloc은 응용 프로그램이 필요로하는 양만큼 운영체제에게 할당을 요청하며, 운영체제는 빈 영역(힙)을 찾아 할당, 시작 번지를 리턴.
	- 100바이트가 필요한 경우, `malloc(100)`이라고 호출
	- 할당한 메모리를 어떤 목적으로 사용하는지 모르므로 void `*`형을 리턴
- `free`: 동적으로 할당한 메모리를 해제. 메모리의 사용이 끝났을 경우 반드시 사용하여 메모리를 해제해야 함.
- malloc은 할당에 실패할 경우 NULL값을 에러 표시로 리턴하며, 때문에 반드시 리턴 번지값이 NULL인지 확인하는 절차가 필요.
- free로 메모리를 해제하지 않을 경우, 해당 메모리는 시스템이 재부팅 될 때 까지 컴퓨터에서 사용할 수 없음.

### 재할당
- calloc
	- `void *calloc(size_t num, size_t size);
	- malloc과는 달리 원하는 메모리의 개수 역시 지정 가능: `calloc(10,sizeof(int))`
	- malloc과 달리 메모리 할당 후 전부 0으로 초기화(malloc은 쓰레기값)
- realloc
	- `void *realloc(void *memblock, size_t size);`
	- 이미 할당된 메모리의 크기를 바꾸어 재할당하는 함수
	- 첫번째 인수로 할당된 메모리의 시작 번지, 두번째 인수로 재할당할 크기를 전달
	- 첫번째 인수가 NULL일 경우, 할당되어 있지 않다는 뜻이므로 malloc과 같은 역할 수행
	- 두번째 인수가 0일 경우, free와 같은 역할 수행
	- 재할당 후 리턴하는 번지는 원래 번지와 같을 수도, 다를 수도 있음.

## 이중 포인터
### 이중 포인터
- 이중 포인터, 포인터 변수를 가리키는 포인터. 즉, 포인터의 포인터
	- `int **p`: 이중 포인터 선언
- `*` 연산자를 붙이는 것에는 제한이 없음.
![이중포인터.png](.\image\이중포인터.png)

### main 함수의 인수
- main 함수의 원형
	- `void(or int) main(int argc,char *argv[],char *env[]);
- 가능한 main 함수의 형태
	1. void main(void);
	2. void main(int argc);
	3. void main(int argc,char *argv[]);
	4. void main(int argc,char *argv[],char *evn[]);
	5. int main(void);
	6. int main(int argc,char *argv[]);
	7. int main(int argc,char *argv[],char *evn[]);
- return
	- 리턴값은 없거나 정수형
	- 리턴 값은 탈출 코드라고 부름: main함수의 리턴값은 곧 프로그램의 리턴갑싱 됨
	- main함수에 한해 return값을 생략할 수 있음(경고만 나옴)
- argc
	- 프로그램을 실행했을 때 전달되는 인수의 개수
	- 첫 번째 인수는 실행 파일명으로 고정되어 있고, 때문에 argc는 항상 1보다 큼
		- `boksa file1.txt file2.txt`: 총 3개의 인수를 가지고 있음
	- 필요한 개수만큼의 인수가 없을 경우 에러메세지 출력 후 프로그램 종료. 혹은 디폴트값을 취해야 함
- argv
	- 프로그램으로 전달된 실제 인수값
		- `boksa file1.txt file2.txt`: 인수값은 "boksa", "file1.txt", "file2.txt"
	- 원형은 `char * argv[]`이며, 이는 이중 포인터를 의미
	- `argv[0]`은 항상 프로그램의 이름을 의미
- env
	- 운영체제의 환경 변수를 의미