# 배열과 포인터
## 첨자 연산
### 배열의 내부적 처리
- C언어의 배열은 다음과 같은 특징을 가지고 있음
	- C는 내부적으로 1차원 배열만을 지원하며, 다차원 배열은 결국 1차원 배열의 확장에 불가
	- 배열을 구성하는 배열 요소의 타입에는 제한이 없음. 배열 그 자체가 배열의 요소가 되는 것 역시 가능
	
### `[ ]` 연산자
- 연산자의 정의: `ptr[n]==*(ptr+n)`. 단, ptr: 포인터, n: 정수
	- 때문에, `ar[i]==*(ar+2)==*(2+ar)==2[ar]` 성립
	- `[]` 연산자는 괄호의 의미를 포함하여 `*` 연산자보다 더 우선시됨
- 다차원 배열의 경우, `a[i][j]==*(*(a+i)+j)`로 정의됨
	- `*(a+i)`는 하나의 부분배열이며, `sizeof(*(a+i))`는 `a[i]`부분배열의 전체 크기를 출력

## 포인터 배열
### 정의
- 포인터 배열은 요소가 포인터형이 배열을 의미
- `int *a[3]` 식으로 선언
- 문자형 포인터 배열, 구조체 포인터 배열이 자주 사용됨
 
### 포인터와 배열
- 배열과 포인터는 비슷한 점을 가지고 있음
	- 동일 타입의 변수 집합을 다룰 수 있음
	- 범위 점검이 불가능
	- 할당한 크기만큼의 크기를 가지고 있음(배열: 선언 시 지정, 포인터: malloc 등으로 동적 배열 지정)
- 차이점
	1. 포인터는 변수이지만 배열은 상수: 포인터는 고유의 메모리를 가지고 있고 다른 대상을 가리키는 것도 가능하지만, 배열은 그 위치가 고정되어있음
	2. 배열은 동적으로 크기를 결정할 수 없음
	3. 배열은 크기가 커 함수의 인수로 전달이 불가능한 데 반해, 포인터는 가능: 때문에, 배열을 함수로 전달할 때에는 반드시 포인터를 사용해야 함
	4. 포인터는 대상체로 직접 이동하여 읽는 반면, 배열의 첨자 연산은 매번 배열 선두에서 출발하여 읽음: 포인터가 배열보다 읽는 속도가 두배 가량 빠르다

## 배열 포인터
### 배열 포인터
- 배열의 번지를 담은 포인터 변수. 포인터가 가리키는 대상은 배열형이며 포인터가 가리키는 배열의 요소는 임의의 타입을 가짐
	- `int (*p)[4]` 식의 형식을 가짐
	- `[]` 연산자에는 2차 이상의 첨자만을 명시
		- 3차 배열의 경우, `int (*p)[3][4]`: 첨자들은 각각 2차, 3차 점자 크기를 의미
	- `p+1`은 다음 부분배열을 의미(이차배열 a에서, a+1은 a[1][0] 의미)
- 배열 포인터는 자신이 가리키는 대상체 배열의 크기를 정확하게 기억하고 있으며, 따라서 타입이 다른 변수는 대입이 불가능함
	- `int (*)[7]` 타입을 `int (*)[8]` 타입으로 바꿀수는 없음(캐스팅 필요)
- 함수의 인수로 배열을 사용할 경우, `void func(int a[5])`형식의 사용은 가능하나, 원칙적으로는 불가능
	- 원칙적으로 가능한 인수의 형태는 다음 두가지
		1. `int *ar`: 인수가 포인터라는 것을 강조
		2. `int ar[]`: 인수가 배열로부터 온 포인터라는 것을 강조
	- 배열의 수는 따로 정수형 인수로 지정하여 함수에 넘겨야 함

### 이차 배열 인수
- 이차 이상의 배열을 인수로 전달할 때에는 배열 포인터를 사용해야 함
	- `void func(int (*ar)[3], int size)`: 크기 3의 배열 포인터와 개수(size)를 인수로 취함
	- `void func(int ar[][3], int size)`의 형식도 가능`
- 일반적으로 이차원 배열을 인수로 사용하는 경우는 별로 없음

### 이차 배열 할당
- 다차원 배열을 동적으로 할당받기 위해서는 배열 포인터가 필요함
	- `char (*p)[4]=(char (*)[4])malloc(n*4*sizeof(char))`
	- 여기서 p는 `char ar[n][4]` 정적 배열을 동적으로 할당한 것
	- 하지만 이경우, 일차,이차 첨자를 전부 변수로 지정할 경우, 에러메세지 출력
		- 이차첨자 요소수가 4로 고정되어있기 때문
		- 두 첨자를 동시에 변수로 고려하기 위해서는 이중 포인터가 필요
```cpp
char **p;
p=(char **)malloc(n*sizeof(char *));  //일차첨자 요소수 설정
for(i=0;i<n;i++)
{
	p[i]=(char *)malloc(m*sizeof(char)); //이차첨자 요소수 설정
}
```
	- 정적으로 할당된 이차 배열과 같은 역할을 수행 가능
	- 하지만, 배열처럼 부분 배열의 주소가 붙어있지 않으며, 각 일차 요소마다의 이차요소수를 임의로 조정 가능

### &ar
- `int ar[5]={1,2,3,4,5}`일 경우, 배열 ar의 타입은 `int * const`
- `&ar`의 타입은 `int (*)[5] const`인 상수형 배열 포인터
- `&ar+1`은 배열의 시작점에서 20바이트 떨어진 곳을 가리킴

## 배열과 문자열
### 문자열 상수
- 프로그램은 문자열 상수들을 정적 데이터 영역에 기록
	- 일반적인 변수들은 크기가 작아 코드에 곧바로 기록할 수 있는 데에 반해, 문자열은 크기가 크기 때문에 코드에 기록하지 않고 다른 영역에 기록한 뒤 포인터를 사용함
	- 해당 영역은 RO data 영역이라 하며, 오로지 읽는 것만 가능
	- 컴파일러는 문자열 상수를 기록할 때 끝에 항상 널 종료 문자를 첨부함
	- 코드에서의 문자열 상수는 이 문자열의 시작 번지를 가리키는 문자형 포인터 상수로 평가됨
	- 같은 문자열 상수를 두 번 이상 사용할 때, 해당 문자열은 한 번만 기록됨
	- 컴파일러는 공백이나 탭, 개행 코드 등으로만 구분된, 중간에 콤마나 영문자 등이 없는 연속된 문자열 상수들을 하나로 합쳐서 기록

### 문자 배열 초기화
- C에는 문자열형이 없으며, 문자형 배열을 통해 문자열을 표현
- 문자형 배열의 초기화는 다른 타입과는 다른 방법의 초기화를 허용
	- `char str[]="I like you"`: 문자형은 각 자리의 크기가 일정하여 문자끼리 확실하게 구분되고 바이트 단위로 복사하는 것이 가능하기 때문

### 문자형 포인터
- 문자열의 시작 번지를 저장할 수 있는 문자형 포인터를 통해 문자열을 다룰 수 있음
	- `char *ptr="Korea";`
- 문자형 포인터는 변수이므로, 실행 중 얼마든지 다른 문자열을 가리킬 수 있음
- 하지만, 문자열의 내용을 바꿀 수는 없음
- 문자배열명은 포인터 상수이므로, 포인터 변수처럼 다른 문자열을 가리키는 것이 불가능
- 하지만, 배열은 문자열의 사본을 가지고 있어, 문자열의 내용을 바꾸는 것이 가능

### 문자열 배열
- 문자열의 배열의 표현에는 이차원 배열을 이용
	- `char a[][32]={"Korea","America"};`
- 1차 포인터 배열을 이용하여 표현하는 것 역시 가능
	- `char *a[]={"Korea","America"};`
		- 배열의 가로크기가 문자열마다 다름: 메모리 절약이 가능
		- 반면, 문자열의 수정이 불가능
- 2차원 배열의 문자열 역시 만들 수 있음
	- 문자형 3차 배열을 이용
	- 문자형 포인터 2차 배열을 이용